{"meta":{"title":"皇姑区第一亚索的博客","subtitle":"","description":"什么都写","author":"皇姑区第一亚索","url":"https://yiyayamaya.github.io","root":"/"},"pages":[{"title":"","date":"2021-07-03T02:10:53.808Z","updated":"2021-07-03T02:10:53.808Z","comments":true,"path":"baidu_verify_code-qN80MMuwcY.html","permalink":"https://yiyayamaya.github.io/baidu_verify_code-qN80MMuwcY.html","excerpt":"","text":"8de2d0cecd270023ec4d781859ab46a5"},{"title":"","date":"2021-07-03T02:17:30.791Z","updated":"2021-07-03T02:17:30.791Z","comments":true,"path":"google7df335c6cac00dc5.html","permalink":"https://yiyayamaya.github.io/google7df335c6cac00dc5.html","excerpt":"","text":"google-site-verification: google7df335c6cac00dc5.html"},{"title":"about","date":"2021-05-18T12:43:17.015Z","updated":"2021-05-18T12:43:17.015Z","comments":true,"path":"about/index.html","permalink":"https://yiyayamaya.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-18T12:43:17.015Z","updated":"2021-05-18T12:43:17.015Z","comments":false,"path":"categories/index.html","permalink":"https://yiyayamaya.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-18T12:43:17.015Z","updated":"2021-05-18T12:43:17.015Z","comments":false,"path":"tags/index.html","permalink":"https://yiyayamaya.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hashMap treeMap linkedHashMap","slug":"hashMap-treeMap-linkedHashMap","date":"2022-04-01T21:09:24.000Z","updated":"2022-04-01T21:14:55.442Z","comments":true,"path":"2022/04/01/hashMap-treeMap-linkedHashMap/","link":"","permalink":"https://yiyayamaya.github.io/2022/04/01/hashMap-treeMap-linkedHashMap/","excerpt":"","text":"HashMap、LinkedHashMap、TreeMap区别使用场景 HashMap中k的值没有顺序，常用来做统计。 LinkedHashMap吧。它内部有一个链表，保持Key插入的顺序。迭代的时候，也是按照插入顺序迭代 TreeMap的顺序是Key的自然顺序（如整数从小到大），也可以指定比较函数。但不是插入的顺序","categories":[],"tags":[]},{"title":"懈怠时应该想的","slug":"懈怠时应该想的","date":"2022-03-26T21:03:29.000Z","updated":"2022-03-27T00:05:55.780Z","comments":true,"path":"2022/03/26/懈怠时应该想的/","link":"","permalink":"https://yiyayamaya.github.io/2022/03/26/%E6%87%88%E6%80%A0%E6%97%B6%E5%BA%94%E8%AF%A5%E6%83%B3%E7%9A%84/","excerpt":"","text":"群友高考比自己低但是挣得比自己多的人大学同学马上奔3 最后的机会就是25之前","categories":[],"tags":[]},{"title":"cs 570 迷宫作业的思考","slug":"cs-570-迷宫作业的思考","date":"2022-03-26T19:12:38.000Z","updated":"2022-03-27T00:15:24.035Z","comments":true,"path":"2022/03/26/cs-570-迷宫作业的思考/","link":"","permalink":"https://yiyayamaya.github.io/2022/03/26/cs-570-%E8%BF%B7%E5%AE%AB%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"迷宫作业要求https://drive.google.com/file/d/1PX44v9dnboodE5qrMB0PsvmVGwTDOXjB/view?usp=sharing 从给定起点是否能够走到终点 如果这个点不是红色可走 不能(为什么需要这么标记？)如果界外 不能出口之终极出口 如果已经是终点 加入path 返回能如果递归能找到任何一个方向的一个 其他也有可能的方向是否被加入了？我认为不应该被加入 加入path 返回true {有没有一种可能 好好走能走 因为选择了错误的路 堵死了本来可行的路应该是没有 一个点可以往堵死可行的走 证明他可以走到可行 那可行的也不过是走到这个点可行的可以走到更多点 因为过来了才走不到？没可能 过来了的之影响了过来了的璐}如果递归都失败了 Java中的短路逻辑运算符 如果逻辑表达式的求值在完成求值之前退出，则称为短路。发生短路是因为即使在表达式的完整计算之前结果就很清楚了，并且返回了结果。短路评估避免了不必要的工作并导致高效处理。 在 AND 的情况下，表达式会被计算直到我们得到一个错误的结果，因为结果总是错误的，与其他条件无关。如果存在带有 &amp;&amp;(逻辑与) 的表达式，并且第一个操作数本身为假，则发生短路，不计算进一步的表达式，并返回假。 短路走法一个走通了立马不试别的了vs不短路走法 一个走通了也要试试别的只找一条路短路走法就好了不短路走法会把一些路径变黑 找所有路径 bfs dfs都可以https://blog.csdn.net/K346K346/article/details/51289478 二叉树的基本bfs dfs写法是几乎一摸一样的 只是queue和stack的区别 while{ pop/poll 操作 Left非空则进 right非空则进}","categories":[],"tags":[]},{"title":"mysql group by 时候空值的问题","slug":"mysql-group-by-时候空值的问题","date":"2022-03-25T19:03:04.000Z","updated":"2022-03-26T04:48:19.587Z","comments":true,"path":"2022/03/25/mysql-group-by-时候空值的问题/","link":"","permalink":"https://yiyayamaya.github.io/2022/03/25/mysql-group-by-%E6%97%B6%E5%80%99%E7%A9%BA%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"使用group by子句如何显示count()等于0的结果https://blog.csdn.net/qq_24309787/article/details/84976762 #TODO 子查询里的counthttps://blog.csdn.net/qq_35456045/article/details/105180611561 lecture4里面第一次出现 lecture5 lecture6里都有讲解有空看一下","categories":[],"tags":[]},{"title":"HTTP request 和response","slug":"HTTP-request-和response","date":"2022-01-24T06:24:30.000Z","updated":"2022-01-27T01:55:02.231Z","comments":true,"path":"2022/01/24/HTTP-request-和response/","link":"","permalink":"https://yiyayamaya.github.io/2022/01/24/HTTP-request-%E5%92%8Cresponse/","excerpt":"","text":"http消息结构两种命名体系 场景：想要post下载文件，因为get下载文件参数只能 通过url传递，长度受限制。 ps.jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。 从上面的解释中可以知道：ajax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。 所以我用一句话来总结两者的关系：我们使用XMLHttpRequest对象来发送一个Ajax请求。 也就是本来用XMLHttpRequest发最朴素的http psot/get，有了ajax以后就用ajax发 http post/get，省得每次都创建操作XMLHttpRequest。 ajax post和表单post的区别 没有区别，只是 AJAX 是，正如首字母缩写词所暗示的那样，是异步的，这意味着它不会阻止其他任何东西运行。表单和 AJAX 请求都发送 POST 请求，唯一的区别是浏览器使用表单 POST 请求的响应来加载新页面，其中 AJAX 请求响应被传递给 JavaScript 中的回调。 Ajax 请求是在后台异步发送的 xhr 请求，由您的 javascript 代码处理，而表单请求是普通请求，将重新加载浏览器页面以及浏览器呈现的响应 提交 HTML 表单会构造一个根据为 HTML 表单定义的规则格式化的 HTTP 请求，并使浏览器导航到它获得的响应。 使用 JavaScript 发出请求允许编程构建更多种类的请求——包括添加自定义标头、以不同方式（例如 JSON）格式化数据，以及与 HTML 表单构建请求的方式相同——并导致响应用 JavaScript 处理。 为什么不能用ajax下载？ajax请求返回的参数是json,text,html,xml类型，ajax不能调用IO流，所以不可以完成下载功能，ajax可以获取文件的数据，但是不能保存到磁盘，为了保证计算机安全，JS不可以和磁盘进行交互。 Hi Amanda, My name is Xingjian Wu and I was originally admitted to 21Fall semester and I deferred to 22Spring. But my visa is issued util this march. So I chose to take courses as a non-maticulating student this Spring semester. Before about January 10th, I am not sure the time when I can arrive US. Once I know I can arrive US on March, I submit the non-matriculating application. （In the process, I keep communicating with Bianka.） But after the application approveled. There are few courses avaliable. I originally wrote CS561WS and CS545WS in the non-matriculating application form, and I have enrolled in CS561WS successfully but my override application for CS545WS was rejected (I have submitted an application for the second time and it is in progress now).I would like to enroll in two more courses in addition to the CS561WS, any two from CS545WS, CS546WS, CS570WS, CS574WS. But they are either closed or I am not eligible. I submitted the Request Enrollment in Closed Course Section for CS546WS and CS570WS. Can you please help me approve it? What may happen if I enroll in a course from workday before notifying non-matriculating apartment? (For example, CS546WS releases a seat, and I enroll in it but it is not on my non-matriculating application form) 通过contoller传过去参数 下载&lt;-&gt;get跳转一次 从8991发到8999 从8999再发到8999 不reset 跨域仍在 不影响下载 用post来下载 vs 用表单get/表单post来下载 表单的get post和http get post的关系？ 尝试1 get里加消息体 不会、post ajax没有跨域问题 get ajax有跨域问题？ in () 有bug chrp 为什么ajax不允许写磁盘 为什么表单就可以 0不能跳 不能点击 颜色黑色 ⬇️⬇️ {1：[],2:[],3:[]} 前：前后：后前：后后：前 span6～12的父亲的a都去掉 List&lt;Map&lt;Integer,String&gt;&gt;}","categories":[],"tags":[]},{"title":"创建List或者Map的时候指定类型与不指定类型有什么区别","slug":"创建List或者Map的时候指定类型与不指定类型有什么区别","date":"2022-01-04T02:40:44.000Z","updated":"2022-01-04T07:07:39.367Z","comments":true,"path":"2022/01/03/创建List或者Map的时候指定类型与不指定类型有什么区别/","link":"","permalink":"https://yiyayamaya.github.io/2022/01/03/%E5%88%9B%E5%BB%BAList%E6%88%96%E8%80%85Map%E7%9A%84%E6%97%B6%E5%80%99%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"https://bbs.csdn.net/topics/390949113 如：创建一个ListList list = new ArrayList();List list = new ArrayList();创建一个MapMap map = new HashMap();Map&lt;String,String&gt; map = HashMap&lt;String,String&gt;();指定类型与不指定类型，这两种方式在底层有什么区别，或者在性能上有什么影响呢？ 指定了参数类型编译器在编译期间就会帮助你检查存入容器的对象是不是参数类型！不是就会报错！保证了类型安全！性能上没什么影响，因为泛型在运行期间会擦除！就是说用不用类型参数在运行期间编译后的运行代码是一样的！ Map map = new HashMap(); Map&lt;String,String&gt; map1 =new HashMap&lt;String,String&gt;(); System.out.println(map.getClass().equals(map1.getClass()));返回结果会true；说明他们运行的是同一份字节码！ 一个好的使用泛型的例子 12345678910111213141516171819202122232425Gen&lt;Integer&gt; intOb = new Gen&lt;Integer&gt;(88);intOb.showType();int i = intOb.getOb();System.out.println(\"value= \" + i);System.out.println(\"----------------------------------\");// 定义泛型类Gen的一个String版本Gen&lt;String&gt; strOb = new Gen&lt;String&gt;(\"Hello Gen!\");strOb.showType();String s = strOb.getOb();System.out.println(\"value= \" + s);//-------------------------------------------------------------------------// 定义类Gen2的一个Integer版本Gen2 intOb_ = new Gen2(new Integer(88));intOb_.showTyep();int i_ = (Integer) intOb_.getOb();System.out.println(\"value= \" + i_);System.out.println(\"---------------------------------\");// 定义类Gen2的一个String版本Gen2 strOb_ = new Gen2(\"Hello Gen!\");strOb_.showTyep();String s_ = (String) strOb_.getOb();System.out.println(\"value= \" + s_); 泛型带?的用法 上界通配符 https://www.liaoxuefeng.com/wiki/1252599548343744/1265105899616928 使用类似&lt;? extends Number&gt;通配符作为方法参数时表示： 方法内部可以调用获取Number引用的方法，例如：Number n = obj.getFirst();； 方法内部无法调用传入Number引用的方法（null除外），例如：obj.setFirst(Number n);。 即一句话总结：使用extends通配符表示可以读，不能写。 使用类似定义泛型类时表示： 泛型类型限定为Number以及Number的子类。 所以我的尴尬症就犯了。实际上，编译器脑袋里认定的逻辑是这样的： 苹果 IS-A 水果装苹果的盘子 NOT-IS-A 装水果的盘子所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。原因很明显，因为Plate不是Plate的子类，因此，printFruit(Plate)不接受参数类型Plate。 为了让泛型用起来更舒服，Sun的大脑袋们就想出了&lt;? extends T&gt;和&lt;? super T&gt;的办法，来让“水果盘子”和“苹果盘子”之间发生关系。 Plate&lt;？ extends Fruit&gt; 翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。 supper类似 下面图里表示用了&lt;?extends/super&gt;后能装的范围","categories":[],"tags":[]},{"title":"动态添加dom再绑定事件再解绑事件","slug":"动态添加dom再绑定事件再解绑事件","date":"2021-12-31T06:30:58.000Z","updated":"2021-12-31T07:14:52.628Z","comments":true,"path":"2021/12/31/动态添加dom再绑定事件再解绑事件/","link":"","permalink":"https://yiyayamaya.github.io/2021/12/31/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0dom%E5%86%8D%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%86%8D%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"需求：动态添加的多个dom对,需要分别绑定事件。而且要往事件里面传参。 遇到的几个问题：1.动态添加dom,因为是动态添加的dom,不能使用 $(‘#dom的id’).on(‘click’, function () {}); 这种方式 必须用$(document).on $(document).on的原型有两种 2.$(document).on的selector用class还是id？如果用class是每个dom绑定一次还是添加后所有dom按class绑定一次？ 不能每个dom绑定一次，这样前面添加的dom都被多次。所有dom按照class绑定一次,这样不能分别传参。最后每个每一个id有一个on绑定。 12345678910111213141516for (let dataKey in data) &#123; var dataValue=data[dataKey]; $(\"#exeStatWindow\").append( '&lt;button class=\"layui-btn \" id=\"'+ip+dataKey+ '\"&gt;'+dataKey+'&lt;/button&gt;') var selector=\"#\"+ip+dataKey selector=selector.replaceAll(\":\",\"\\\\:\") selector=selector.replaceAll(\".\",\"\\\\.\") //每一个id有自己的一个on绑定 $(document).on( &#123;'click.myevent': function(e)&#123; openExeStatTable(e.data.dataKey,e.data.dataValue) &#125;&#125;,selector, &#123; dataKey: dataKey, dataValue: dataValue &#125;);&#125; 3.seletor里面的冒号需要转义 4.添加dom成功了也通过事件传参成功了。但是如果一个dom被添加了两次就会重复，所以每次添加前先把之前的remove。问题出现了，虽然dom没了,但是它绑定的事件还在,又会一个第二次添加的dom，绑上了第一次的事件，身上有了两个事件。解决：每次remove dom之前把它这个id绑定的事件给$(document).off掉 。 （因为之前是通过id给on上的所以现在也用id给off掉 我试了id给on上 用class给off掉 貌似不行 不确定） 1234567891011end: function () &#123; var father=$(\"#exeStatWindow\")[0] var childs = father.childNodes; for(var i = childs.length - 1; i &gt;= 0; i--) &#123; console.log( $(childs[i])[0].id) var selector=\"#\"+$(childs[i])[0].id $(document).off('click.myevent', selector); childs[i].remove() &#125;&#125;, 5.得保证每个dom唯一id 6.我发现其实没必要硬要通过绑定事件传参，每个dom通过自己id从全局变量里读就行了。 7.我发现layui那lay-filter实现了这个功能(动态添加的dom绑定了能传参的事件) 而且我以前还用过 想看看他怎么实现的 完全看不懂","categories":[],"tags":[]},{"title":"css display:inline display:block","slug":"css-display-inline-display-block","date":"2021-12-21T11:50:12.000Z","updated":"2021-12-22T02:01:48.062Z","comments":true,"path":"2021/12/21/css-display-inline-display-block/","link":"","permalink":"https://yiyayamaya.github.io/2021/12/21/css-display-inline-display-block/","excerpt":"","text":"在&lt;p&gt;&lt;/p&gt; 标签里面嵌套 div 等 原生块级元素 会在渲染页面时候出错，div 标签会出现在p标签的下方并且和p标签同级。 没有达到 div 是 p 标签的子元素的预期。 这是因为p标签里面不能嵌套原生块级元素。 只需要把 原生块级元素 换为 span 等行内元素就可以实现效果了。并且加上 display : block; 样式也不会出错。 display：block的作用是让其他标签如：a、span等行内元素获得div的特性，比较常用于这两个标签——因为这两个标签非块元素，如果不用display：block定义一下，那么定义width、height等和长宽相关的css属性时会发现完全不生效。 CSS块级元素和行内元素 块级元素： 独占一行；元素的宽高、以及内外边距都可设置；元素宽度在不设置的情况下，是它本身父容器的100%。 行内元素： 不会自动进行换行；元素的宽高不可设置；内边距可以设置、外边距水平方向有效，竖直方向无效；元素宽度在不设置的情况下，随内部元素的内容变化。 我们知道display:inline 和display:block的用发了，他们的作用是将块级元素转化为内联元素或者是内联元素转化为块级元素。 现在的这个貌似是两个的结合体：inline-block 为什么在我加载的这个场景能发挥奇效? 说不清 inline-block是元素具备了两种（块级和内联）元素的功能，inline最重要的一点就是：元素能够在一行展示，block 元素让它能设置宽高(有宽高能显示)。","categories":[],"tags":[]},{"title":"mysql 技术内幕(InnoDB存储引擎)第2版 笔记","slug":"mysql-技术内幕-InnoDB存储引擎-第2版-笔记","date":"2021-12-20T12:22:40.000Z","updated":"2021-12-20T13:03:00.144Z","comments":true,"path":"2021/12/20/mysql-技术内幕-InnoDB存储引擎-第2版-笔记/","link":"","permalink":"https://yiyayamaya.github.io/2021/12/20/mysql-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"https://www.cnblogs.com/gaochundong/p/binary_search_tree.html一个二叉树的查找时间是线性的，定位时间也是线性的，那相比数组来说到底哪里有优势呢？毕竟数组的查找时间虽然是线性 O(n)，但定位时间却是常量 O(1) 啊？的确是这样，通常来说普通的二叉树确实不能提供比数组更好的性能。然而，如果我们按照一定的规则来组织排列二叉树中的元素时，就可以很大程度地改善查询时间和定位时间。","categories":[],"tags":[]},{"title":"Ajax会自动将返回的对象属性首字母转化为小写","slug":"Ajax会自动将返回的对象属性首字母转化为小写","date":"2021-12-16T03:01:47.000Z","updated":"2021-12-16T03:02:12.715Z","comments":true,"path":"2021/12/15/Ajax会自动将返回的对象属性首字母转化为小写/","link":"","permalink":"https://yiyayamaya.github.io/2021/12/15/Ajax%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%A6%96%E5%AD%97%E6%AF%8D%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%B0%8F%E5%86%99/","excerpt":"","text":"不知道是只有ajax还是所有http请求","categories":[],"tags":[]},{"title":"mysql 多行变一行","slug":"mysql-多行变一行","date":"2021-12-16T02:14:50.000Z","updated":"2022-01-14T03:09:54.649Z","comments":true,"path":"2021/12/15/mysql-多行变一行/","link":"","permalink":"https://yiyayamaya.github.io/2021/12/15/mysql-%E5%A4%9A%E8%A1%8C%E5%8F%98%E4%B8%80%E8%A1%8C/","excerpt":"","text":"写的不错SELECT name ,MAX(CASE type WHEN ‘数学’ THEN score ELSE 0 END ) math,MAX(CASE type WHEN ‘英语’ THEN score ELSE 0 END ) English ,MAX(CASE type WHEN ‘语文’ THEN score ELSE 0 END ) ChineseFROM stuGROUP BY namehttps://blog.csdn.net/rainyspring4540/article/details/50231435 这个case when的写法一步一步演变 12345678910SELECT version,group_concat(type,':',score) step0, group_concat(type,':',CASE type WHEN '0' THEN score ELSE 0 END) step1, group_concat(CASE type WHEN '0' THEN score ELSE 0 END) step2, MAX(CASE type WHEN '0' THEN score ELSE 0 END) step3 FROM (select client_file_version version, machine_type type, count(*) score from atc_machine group by client_file_version, machine_type) table_a GROUP BY version; 结果如下 如果想统计1和2的可以这么写SUM(CASE WHEN type in(‘1’,’2’) THEN score ELSE 0 END) yier, 这篇没咋看https://www.cnblogs.com/weix-l/p/7521278.html 乱入讲join性能的因为之前写了一个复杂的(机器类型:总数) left join (机器类型:具有心跳机器数) left join (机器类型:开启机器数) 变成了 (机器类型:总数:具有心跳机器数:开启机器数) 123456789101112131415select a.machineType, a.totalCount, b.machineWithLivingHeartbeatCount, c.machineStatusOnCount from (select machine_type machineType, count(*) totalCount from atc_machine group by machine_type) a left join (select machine_type, count(*) machineWithLivingHeartbeatCount from atc_machine where DATE_ADD(last_heartbeat, INTERVAL #&#123;interval&#125; MINUTE) &gt; NOW() group by machine_type) b on a.machineType = b.machine_type left join (select machine_type, count(*) machineStatusOnCount from atc_machine where status = 1 group by machine_type) c on a.machineType = c.machine_type; https://database.51cto.com/art/202011/631613.htm","categories":[],"tags":[]},{"title":"开坑之WebSecurityConfigurerAdapter","slug":"开坑之WebSecurityConfigurerAdapter","date":"2021-12-15T07:28:48.000Z","updated":"2021-12-15T07:48:31.974Z","comments":true,"path":"2021/12/15/开坑之WebSecurityConfigurerAdapter/","link":"","permalink":"https://yiyayamaya.github.io/2021/12/15/%E5%BC%80%E5%9D%91%E4%B9%8BWebSecurityConfigurerAdapter/","excerpt":"","text":"maven里依赖了 org.springframework.boot spring-boot-starter-security 就导致页面上要登陆 密码是随机生成的 在日志里有 然后加一个public class SecurityConfiguration extends WebSecurityConfigurerAdapter {}的配置这玩意有什么用 不加行不行 https://spring.io/blog/2013/07/03/spring-security-java-config-preview-web-security/#wsca 可能会从雷丰阳带你过spring源码中学到这个 可是我只看了几集","categories":[],"tags":[]},{"title":"开坑之maven怎么排除parent里面的依赖","slug":"开坑之maven怎么排除parent里面的依赖","date":"2021-12-15T07:25:09.000Z","updated":"2021-12-15T07:27:44.373Z","comments":true,"path":"2021/12/15/开坑之maven怎么排除parent里面的依赖/","link":"","permalink":"https://yiyayamaya.github.io/2021/12/15/%E5%BC%80%E5%9D%91%E4%B9%8Bmaven%E6%80%8E%E4%B9%88%E6%8E%92%E9%99%A4parent%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BE%9D%E8%B5%96/","excerpt":"","text":"maven parent中的依赖不能用exclude排除 https://blog.csdn.net/qq_32596527/article/details/112969562试了 在我的项目里有问题 不知道和 pom import 有没有关系 https://stackoverflow.com/questions/2681759/is-there-anyway-to-exclude-artifacts-inherited-from-a-parent-pom一个回答说了一堆没看懂几条 感觉应该系统学习下maven的配置","categories":[],"tags":[]},{"title":"same-origin policy与跨域资源共享CORS","slug":"same-origin-policy与跨域资源共享CORS","date":"2021-12-15T05:48:58.000Z","updated":"2021-12-21T06:11:15.714Z","comments":true,"path":"2021/12/15/same-origin-policy与跨域资源共享CORS/","link":"","permalink":"https://yiyayamaya.github.io/2021/12/15/same-origin-policy%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS/","excerpt":"","text":"浏览器同源政策及其规避方法http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html 跨域资源共享 CORS 详解https://www.ruanyifeng.com/blog/2016/04/cors.html此篇文章貌似没给出太具体的解决 springboot被请求的api 可以加@CrossOrigin解决 https://www.cnblogs.com/xdp-gacl/p/3789624.html HttpServletResponse对象介绍 https://www.jianshu.com/p/8bc6b82403c5 一篇差不多的介绍 貌似结构清晰一些 同一个人讲的 HttpServletRequest和HttpServletResponsehttps://blog.csdn.net/qq_34666857/article/details/104677407 https://blog.csdn.net/qq_34666857/article/details/104838171 廖雪峰结合servlet讲的https://www.liaoxuefeng.com/wiki/1252599548343744/1328705066500130 Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。request和response对象即然代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行了。要向客户机输出数据，只需要找response对象就行了。 HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。查看HttpServletResponse的API，可以看到这些相关的方法。 之前跨域出问题 就是因为@CrosOrigin注解会让spring会往response里加Access-Control-Allow-Origin解决跨域 但是我操作了response把这个头给重置掉 写到这我去试了一下再给那个下载的respose加一个Access-Control-Allow-Origin头 果然跨域问题解决了 http get 可以开始下载 ajax get url不能开始下载 为什么？ 其实硬要也可以 但是通常都是http get啊https://www.cnblogs.com/nuccch/p/7151228.html 1，负责向客户端(浏览器)发送数据的相关方法 ** 1.getOutputStream() 该方法用于返回Servlet引擎创建的字节输出流对象，Servlet程序可以按字节形式输出响应正文。2.getWriter() 该方法用于返回Servlet引擎创建的字符输出流对象，Servlet程序可以按字符形式输出响应正文。","categories":[],"tags":[]},{"title":"mysql 求时间的绝对差 timediff 有坑","slug":"mysql-求时间的绝对差-timediff-有坑","date":"2021-12-14T08:47:16.000Z","updated":"2021-12-14T08:50:16.694Z","comments":true,"path":"2021/12/14/mysql-求时间的绝对差-timediff-有坑/","link":"","permalink":"https://yiyayamaya.github.io/2021/12/14/mysql-%E6%B1%82%E6%97%B6%E9%97%B4%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%B7%AE-timediff-%E6%9C%89%E5%9D%91/","excerpt":"","text":"SELECT TIMEDIFF(“00:00:03”, “00:00:02”);结果00:00:01 SELECT TIMEDIFF(“00:00:03”, “00:00:02”);结果也是00:00:01 但是跨天又正常了 SELECT timediff(‘2010-01-01 01:00:00’, ‘2010-01-02 01:00:00’);-24:00:00","categories":[],"tags":[]},{"title":"以前看到过一篇很好的大offset limit优化的文章 现在找不到了","slug":"以前看到过一篇很好的大offset-limit优化的文章-现在找不到了","date":"2021-11-30T02:17:34.000Z","updated":"2021-12-09T08:55:52.908Z","comments":true,"path":"2021/11/29/以前看到过一篇很好的大offset-limit优化的文章-现在找不到了/","link":"","permalink":"https://yiyayamaya.github.io/2021/11/29/%E4%BB%A5%E5%89%8D%E7%9C%8B%E5%88%B0%E8%BF%87%E4%B8%80%E7%AF%87%E5%BE%88%E5%A5%BD%E7%9A%84%E5%A4%A7offset-limit%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%87%E7%AB%A0-%E7%8E%B0%E5%9C%A8%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86/","excerpt":"","text":"之前是某公司的ppt 现在找不到了 找到了 妈的 https://www.slideshare.net/slideshow/view?login=Eweaver&amp;preview=no&amp;slideid=1&amp;title=efficient-pagination-using-mysql https://stackoverflow.com/questions/4481388/why-does-mysql-higher-limit-offset-slow-the-query-down MySQL cannot go directly to the 10000th record (or the 80000th byte as your suggesting) because it cannot assume that it’s packed/ordered like that (or that it has continuous values in 1 to 10000). Although it might be that way in actuality, MySQL cannot assume that there are no holes/gaps/deleted ids. So, as bobs noted, MySQL will have to fetch 10000 rows (or traverse through 10000th entries of the index on id) before finding the 30 to return. EDIT : To illustrate my point Note that although SELECT * FROM large ORDER BY id LIMIT 10000, 30would be slow(er), SELECT * FROM large WHERE id &gt; 10000 ORDER BY id LIMIT 30would be fast(er), and would return the same results provided that there are no missing ids (i.e. gaps). MySQL 不能直接转到第 10000 条记录（或您建议的第 80000 字节），因为它不能假设它是这样打包/排序的（或者它在 1 到 10000 之间具有连续值）。尽管实际上可能是这样，但 MySQL 不能假设没有漏洞/间隙/删除的 id。因此，正如 bob 所指出的，id在找到要返回的 30 行之前，MySQL 必须获取 10000 行（或遍历索引的第 10000 个条目）。 请注意，虽然 SELECT * FROM large ORDER BY id LIMIT 10000, 30会很慢（呃）， SELECT * FROM large WHERE id &gt; 10000 ORDER BY id LIMIT 30 将是fast(er)，并且会返回相同的结果，前提是没有丢失的ids（即间隙）。","categories":[],"tags":[]},{"title":"List=new ArrayList写法的意义","slug":"List=new-ArrayList写法的意义","date":"2021-11-19T07:29:21.000Z","updated":"2022-01-20T06:03:56.434Z","comments":true,"path":"2021/11/19/List=new-ArrayList写法的意义/","link":"","permalink":"https://yiyayamaya.github.io/2021/11/19/List=new-ArrayList%E5%86%99%E6%B3%95%E7%9A%84%E6%84%8F%E4%B9%89/","excerpt":"","text":"本文问题的兄弟问题 https://segmentfault.com/q/1010000040306308 我提的问题父类 x = new 子类();的意义 List list = new ArrayList&lt;&gt;();多年来令我费解这个问题的不同问法有为什么面向接口编程？ 插曲实现接口的方法一定要声明为public，因为接口中定义的方法都是默认为public（可以省略不写）的。 这个回答讲的很好烦人的苍蝇和烦人的电话推销员的例子但是他讲的是为什么要用接口 不能回答上面的问题 L l=new AL;https://stackoverflow.com/a/384067 我惊讶地发现实现了同一个接口的两个类居然都可以放进参数声明为借口的方法中这么基本的功能我现在才意识到比如 123456789101112131415比如IPest[] iPestsArr=new IPest[]&#123;telemarketer1,telemarketer2,houseFly1,houseFly2&#125;;再比如IPest就是恼人行为的接口 void inviteIPestOnly(IPest iPest) &#123; iPest.BeAnnoying(); &#125; class HouseFly implements IPest HouseFly houseFly1 = new HouseFly(); diningRoom.inviteIPestOnly(houseFly1); 接口可以被理解成弱化的继承。他也是一种分类手段，当不同类的对象(电话推销员、苍蝇)表现出相同特征(恼人)时通过这个特征来分类。原文:I finally understood their use as a language construct by thinking of them as a means of classifying common traits or behaviors that were exhibited by potentially many non-related classes of objects. 插播下策略模式interface Fly, interface highhighFly extends Fly, interface landFly extends Fly 123456789public abstract class Duck &#123; protected FlyBehavior flyBehavior; public void performFly() &#123; flyBehavior.fly(); &#125;&#125; 定义下策略模式：定义了算法族(陆地飞、高高地飞)，分别封装起来让他们可以相互替换。让算法的变化独立于使用算法的客户(各种duck)。 这样做的好处之一这个设计在 DiningRoom 和各种 Pests 之间耦合得足够松散，你可以引入新的害虫（想想 class Covid19 implements IPest {…};！），在编写 DiningRoom 类时甚至不存在！您不仅不需要更改Diningroom，甚至不需要重新编译它！在测试和大型项目中派上用场 但是上面的写法仅仅解释了为什么用接口 而没有解释HouseFly houseFly1 = new HouseFly();InterfaceAnnoying houseFly1 = new HouseFly(); 两种写法的区别。在这里例子里两种写法都ok。 同问题下一个更切题的答案stackoverflow.com/a/383982/9868445 我在v2ex上提问https://www.v2ex.com/t/829411#reply26 感觉说的比较好的是 限定只能用 List 的方法。只用和只能用还是有点区别的，这么写最大好处是防手滑。 代码防御； 可以让后面调用的人，只能调用接口声明的方法，而不会误调用 具体实现的某些公开方法。在后续，如果要切换具体的实现，只要替换 new ArrayList 即可，对调用方无感知。 个人提炼：我从一开始 List=new AL 下面我每次用到list的时候都不会碰AL专属的方法。 如果我AL=new AL了 就可能不小心用了一个AL专属方法以后再改成linkedList就不好改了","categories":[],"tags":[]},{"title":"文档","slug":"文档","date":"2021-11-18T02:02:04.000Z","updated":"2021-11-18T03:07:40.240Z","comments":true,"path":"2021/11/17/文档/","link":"","permalink":"https://yiyayamaya.github.io/2021/11/17/%E6%96%87%E6%A1%A3/","excerpt":"","text":"要统计的一天=第一天=atc_task_logs_20211117第二天=atc_task_logs_20211118 一 第一天每个小类型创建数1select task_name,count(*) from atc_task_logs_20211117 where event=1 group by task_name 二 第一天创建的所有任务的独一标志hashKeyreturn${第一天创建的hashKey集合} 1select hash_key from atc_task_logs_20211117 where event=1 and hash_key is not null 三 统计当天成功和第二天成功123456789101112当天成功select task_name,count(*) from atc_task_logs_20211117 where event=4 and hash_key in $&#123;第一天创建的hashKey集合&#125; group by task_name第二天成功select task_name,count(*) from atc_task_logs_20211118 where event=4 and hash_key in $&#123;第一天创建的hashKey集合&#125; group by task_name 四 类似第三步 统计当天强制失败和第二天强制失败123456789101112当天失败select task_name,count(*) from atc_task_logs_20211117 where event=7 and hash_key in $&#123;第一天创建的hashKey集合&#125; group by task_name第二天强制失败select task_name,count(*) from atc_task_logs_20211118 where event=7 and hash_key in $&#123;第一天创建的hashKey集合&#125; group by task_name 五 第一天创建的hashKey第二天也出现了 说明最后一次event出现在第二天return ${结束在第二天的event的id的集合} 1234select max(id) from atc_task_logs_20211118 where hash_key in $&#123;第一天创建的hashKey集合&#125; group by hash_key 五点五 第一天创建的hashKey第二天也出现了 说明最后一次event出现在第二天return ${结束在第二天的hashKey集合} 1234select hash_key from atc_task_logs_20211118 where hash_key in $&#123;第一天创建的hashKey集合&#125; group by hash_key 六 统计第一天的（event=5）失败${第一天创建的hashKey集合} - ${结束在第二天的hashKey集合} = ${结束在第一天的hashKey集合} 12345678910111213select max(id) from atc_task_logs_20211117 where hash_key in $&#123;结束在第一天的hashKey集合&#125; group by hash_keyselect task_name,count(*) from atc_task_logs_20211117 where event=5 and id in $&#123;结束在第一天的event的id的集合&#125; group by task_name 七 类似地 统计下第二天的（event=5）失败12345select task_name,count(*) from atc_task_logs_20211118 where event=5 and id in $&#123;结束在第二天的event的id的集合&#125; group by task_name","categories":[],"tags":[]},{"title":"x86 x86_64 x64这几个说法到底怎么回事","slug":"x86-x86-64-x64这几个说法到底怎么回事","date":"2021-11-17T08:21:06.000Z","updated":"2021-11-17T09:35:34.553Z","comments":true,"path":"2021/11/17/x86-x86-64-x64这几个说法到底怎么回事/","link":"","permalink":"https://yiyayamaya.github.io/2021/11/17/x86-x86-64-x64%E8%BF%99%E5%87%A0%E4%B8%AA%E8%AF%B4%E6%B3%95%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/","excerpt":"","text":"我们现在家用的全都是64位x86指令集 21世纪初家用的以前可能是32位x86指令集 32位x86指令集是英特尔发明的 本来从1980～2000年大家都用的好好的 后来发现32位不够了 想加到64位这时候因特尔飘了 他做了一种不兼容32位x86的64位x86指令集 结果阴险的amd趁机做了一套兼容32位x86的64位x86指令集甚至大言不惭的把这套命名为amd64因特尔很不爽 但也没办法 给amd64起了个小名叫x86_64 来掩盖这个专利归amd所有的事 神发明了重骑女枪 并把它命名为7人口重骑女枪 本来大家都用的好好的 但是赛季末疯狂出花灯暴金币 游戏通常在9人口结束这时候神想更进一步 他把7人口中的人马去掉 多出来的三个人口可以上三个骑士凑出4骑士 这也导致玩法和之前不兼容从而没有流行起来阴险的窃贼手套趁机在神的7人口重骑女枪基础上挂2个秘术 前7个人口完全不变 甚至并大言不惭地把这个阵容命名为许氏重骑女枪因为这个阵容和之前完全兼容 在没脑子的玩家里流传很广神很不爽 但也没办法 但是神坚持叫这套阵容为9人口重骑女枪 来掩盖窃贼手套的贡献","categories":[],"tags":[]},{"title":"springBoot 自动配置遇到的问题","slug":"springBoot-自动配置遇到的问题","date":"2021-10-28T09:20:30.000Z","updated":"2021-10-28T09:24:55.212Z","comments":true,"path":"2021/10/28/springBoot-自动配置遇到的问题/","link":"","permalink":"https://yiyayamaya.github.io/2021/10/28/springBoot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1.配置数据源问题 application.yml可不可以什么都不写？不配置数据源可能会报错 可能需要 @SpringBootApplication(exclude ={ DataSourceAutoConfiguration.class})但是有时候不exclude也不报错？ 不懂为什么 2.用到shardingsphere时候，仅仅在maven中引用，没在任何地方调用就会报错(缺少shardingsphere的数据源配置)。第一次遇见 是因为自动配置吗？ 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;&#x2F;groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;4.1.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;","categories":[],"tags":[]},{"title":"mysql 分组结果的最大值记录","slug":"mysql-分组结果的最大值记录","date":"2021-10-25T12:39:38.000Z","updated":"2021-10-26T07:40:11.066Z","comments":true,"path":"2021/10/25/mysql-分组结果的最大值记录/","link":"","permalink":"https://yiyayamaya.github.io/2021/10/25/mysql-%E5%88%86%E7%BB%84%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E8%AE%B0%E5%BD%95/","excerpt":"","text":"一个常见问题 这类问题有一个名字 greatest-n-per-group 可以在stackOverFlow上看到大量讨论 分组中某栏最大好取 只要 SELECT id, MAX(rev)FROM YourTableGROUP BY id 若是要完整记录呢？有两种方法 一种inner join 一种left join inner似乎快一点？ 12345678--标准答案之inner join 超级快select * from automated_task_center_test_wxj.atc_machine_heartbeat_logs t1 join (select max(heartbeat) a, machine_id b from automated_task_center_test_wxj.atc_machine_heartbeat_logs group by b) t on t1.heartbeat=t.a and t1.machine_id=t.border by machine_id 12345678--标准答案之inner join的另一种写法 和innerjoin语义上是等价 select * from automated_task_center_test_wxj.atc_machine_heartbeat_logs t1, (select max(heartbeat) a, machine_id b from automated_task_center_test_wxj.atc_machine_heartbeat_logs group by b) t where t1.heartbeat=t.a and t1.machine_id=t.border by machine_id 插播1 为什么等价？请教inner join 与一般笛卡尔积的区别，如select * from tb1 a inner join tb2 b on a.id=b.id 与select * from tb1 a ,tb2 b where a.id=b.id 有什么不同？谢谢！答案：等价 笛卡尔积是怎么回事？{a,b},{0,1,2}-&gt;{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)} mysql笛卡尔积是什么写法？笛卡尔积指的是交叉连接，交叉连接的语法格式如下：SELECT &lt;字段名&gt; FROM &lt;表1&gt; CROSS JOIN &lt;表2&gt;或SELECT &lt;字段名&gt; FROM &lt;表1&gt;, &lt;表2&gt;两者等价 为什么笛卡尔积不合理？ 为了避免这种情况的发生，可以采用等值连接的方法 带等值连接的笛卡尔积结果=内联 插播2我这个场景其实只需要 因为id是唯一的 且id大日期一定大 巧妙做法 但是如果需要的最大项不唯一且跟id没规律就不能这么用了 123SELECT *FROM automated_task_center_test_wxj.atc_machine_heartbeat_logsWHERE id in (SELECT MAX(id) FROM automated_task_center_test_wxj.atc_machine_heartbeat_logs GROUP BY machine_id) 1234567891011121314151617--标准答案之left join 不咋快SELECT a.*FROM automated_task_center_test_wxj.atc_machine_heartbeat_logs aLEFT JOIN automated_task_center_test_wxj.atc_machine_heartbeat_logs b ON a.machine_id = b.machine_id AND a.heartbeat &lt; b.heartbeatWHERE b.machine_id IS NULL;-- 为什么left join这么写是对的？How it works:-- It matches each row from o with all the rows from b having the same value in column Group and a bigger value in column Age. Any row from o not having the maximum value of its group in column Age will match one or more rows from b.-- The LEFT JOIN makes it match the oldest person in group (including the persons that are alone in their group) with a row full of NULLs from b ('no biggest age in the group').-- Using INNER JOIN makes these rows not matching and they are ignored.-- The WHERE clause keeps only the rows having NULLs in the fields extracted from b. They are the oldest persons from each group. 1234-- 这个写法貌似也对？我理解不了这个写法 貌似和经典inner等价 https://stackoverflow.com/questions/8470311/get-the-latest-date-from-grouped-mysql-dataSELECT d.machine_id, d.heartbeat, d.cpu, d.memory FROM automated_task_center_test_wxj.atc_machine_heartbeat_logs dWHERE d.heartbeat IN (SELECT max(d2.heartbeat) FROM automated_task_center_test_wxj.atc_machine_heartbeat_logs d2 WHERE d2.machine_id=d.machine_id) 123456--理解不了的写法二 和上面有点像 来自思否中Ewellyuan被质疑的回答 https://segmentfault.com/q/1010000004138670select *from automated_task_center_test_wxj.atc_machine_heartbeat_logs as uwhere u.heartbeat = (select max(heartbeat) from automated_task_center_test_wxj.atc_machine_heartbeat_logs where machine_id = u.machine_id) https://dev.mysql.com/doc/refman/5.7/en/example-maximum-column-group-row.html https://segmentfault.com/a/1190000004157112 https://stackoverflow.com/a/7745635","categories":[],"tags":[]},{"title":"mysql not in GROUP BY clause and contains nonaggregated column","slug":"mysql-not-in-GROUP-BY-clause-and-contains-nonaggregated-column","date":"2021-10-25T02:28:37.000Z","updated":"2021-10-25T02:29:24.628Z","comments":true,"path":"2021/10/24/mysql-not-in-GROUP-BY-clause-and-contains-nonaggregated-column/","link":"","permalink":"https://yiyayamaya.github.io/2021/10/24/mysql-not-in-GROUP-BY-clause-and-contains-nonaggregated-column/","excerpt":"","text":"这篇讲的很好https://www.twle.cn/t/654 今天在做数据统计的时候遇到这个错误 MySQL： 1055 Expression #3 of SELECT list is not in GROUP BY clause and contains nonaggregated column错误愿意大概是：SELECT 的字段列表没有包含在 GROUP BY 语句中 很多年之前都用的好好的，怎么就报错了呢！！！！ 查了一下，哦，这又是 MySQL 5.7 的锅。 only_full_group_byMySQL 其实很早就添加了 only_full_group_by 这个 sql_mode，但一直都作为可选项之一，并没有强制默认。 然而，MySQL 5.7 之后，only_full_group_by 成为 sql_mode 的默认选项之一 这就会让我们的一些惯性思维导致一系列的 SQL 错误 only_full_group_by 这个 sql_mode 的唯一要求，就是所有的 select 字段必须在 group by 字段中，否则必须出现在 SQL Aggregate 函数中，反过来却是非必须的 假设我们有下面一张表 employee id name depart depart_id salary1 小明 技术部 1 250002 小李 产品部 2 320003 小花 技术部 1 350004 小红 UI 部 3 28000CREATE TABLE IF NOT EXISTS employee( id INT UNSIGNED AUTO_INCREMENT, name VARCHAR(64) NOT NULL, depart VARCHAR(128) NOT NULL, depart_id INT UNSIGNED NOT NULL, salary INT UNSIGNED NOT NULL, PRIMARY KEY ( id ))ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; INSERT INTO employee VALUES(1,’小明’,’技术部’,1,25000),(2,’小李’,’产品部’,2,32000),(3,’小花’,’技术部’,1,35000),(4,’小红’,’UI 部’,3,28000);我们要查询每个部门的工资总和，然后又要显示部门名，一种不会触发 only_full_group_by 模式的方法是根据 depart 字段分组 select depart, sum(salary) from employee group by depart输出结果如下 +———–+————-+| depart | sum(salary) |+———–+————-+| 技术部 | 60000 || 产品部 | 32000 || UI 部 | 28000 |+———–+————-+但如果我们一点加了 depart_id，那么就会立马报错 mysql&gt; select depart_id,depart, sum(salary) from employee group by depart;ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column ‘demo.employee.depart_id’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by为什么会这样？ 因为字段既不在分组中也不在 Aggregate 函数中，那么在相同的分组中，这个字段的值可能是不同的，系统不知道要如何选择 解决办法优化代码，剔除 select 语句中的多余字段，也就是不要触发 only_full_group_by。这是值得推荐的，因为这是写出好代码的必要添加之一。 告诉系统，你可以随意返回值，也就是使用 any_value() 函数来包装值 如果你必须要出现这个字段，那么这是推荐的方式 mysql&gt; select any_value(depart_id),depart, sum(salary) from employee group by depart;+———————-+———–+————-+| any_value(depart_id) | depart | sum(salary) |+———————-+———–+————-+| 1 | 技术部 | 60000 || 2 | 产品部 | 32000 || 3 | UI 部 | 28000 |+———————-+———–+————-+3 rows in set (0.00 sec)关闭 sql_mode=ONLY_FULL_GROUP_BY。 在配置文件 my.cnf 中关闭 sql_mode=ONLY_FULL_GROUP_BY 这是最不推荐的方式！！！！！ 千万不要这么做","categories":[],"tags":[]},{"title":"mysql 存储过程","slug":"mysql-存储过程","date":"2021-10-06T05:54:44.000Z","updated":"2021-10-06T05:56:36.554Z","comments":true,"path":"2021/10/06/mysql-存储过程/","link":"","permalink":"https://yiyayamaya.github.io/2021/10/06/mysql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"一次写的mysql造数据脚本 感觉写的不错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184delimiter //DROP PROCEDURE IF EXISTS function_test;CREATE PROCEDURE function_test(event_arr varchar(150),retry_arr varchar(150),task_source_idVal INT,rand_time varchar(25))BEGIN DECLARE event_arr_tmp varchar(150); DECLARE retry_arr_tmp varchar(150); DECLARE eventVal varchar(150); DECLARE retryVal varchar(150); DECLARE i INT default 0; DECLARE random_task_id INT DEFAULT 0; DECLARE task_name_val_arr varchar(1000) default'mt_daily,''mt_monthly,''mt_b2b_monthly,''returns_daily,''returns_monthly,''mt_summary_monthly,''deal,''deal_result,''inventory_age,''vat_monthly,''business_daily,''bank_card,''box_upload,''box_download,''order_shoot,''balance_daily,''balance_quarterly,''account_status,''feedback_daily,''request_review,''storage_free_monthly,''storage_mon_monthly,''referenceid,''amazon_rank,''amazon_rating,''walmart_rank,''get_boss_positions_by_search,''get_boss_positions_by_company,''get_boss_position_detail,''balance_monthly'; DECLARE task_name_val varchar(1000); select 1 + (RAND() * 31) into random_task_id; SET task_name_val = SUBSTRING_INDEX(task_name_val_arr, ',', random_task_id); SET task_name_val = SUBSTRING_INDEX(task_name_val, ',', -1); SET event_arr_tmp=event_arr; SET retry_arr_tmp=retry_arr; WHILE event_arr_tmp != '' DO SET eventVal = SUBSTRING_INDEX(event_arr_tmp, ',', 1); SET retryVal = SUBSTRING_INDEX(retry_arr_tmp, ',', 1); INSERT INTO atc_task_logs(task_source_id, event, result_hash_key, task_name, retry_times, created_time) VALUES (task_source_idVal, eventVal, 0, task_name_val, retryVal, rand_time); select date_add(rand_time, interval 1 second) into rand_time; IF LOCATE(',', event_arr_tmp) &gt; 0 THEN SET event_arr_tmp = SUBSTRING(event_arr_tmp, LOCATE(',', event_arr_tmp) + 1); ELSE SET event_arr_tmp = ''; END IF; IF LOCATE(',', retry_arr_tmp) &gt; 0 THEN SET retry_arr_tmp = SUBSTRING(retry_arr_tmp, LOCATE(',', retry_arr_tmp) + 1); ELSE SET retry_arr_tmp = ''; END IF; END WHILE;end //DROP PROCEDURE IF EXISTS proc_batch_insert;CREATE PROCEDURE proc_batch_insert()BEGIN DECLARE event_arr1 varchar(150) DEFAULT '1,2,3,4'; DECLARE event_arr2 varchar(150) DEFAULT '1,2,3,5,1,2,3,4'; DECLARE event_arr3 varchar(150) DEFAULT '1,2,3,5,1,2,3,5,1,2,3,4'; DECLARE event_arr4 varchar(150) DEFAULT '1,2,3,5,1,2,3,5,1,2,3,5,1,2,3,4'; DECLARE event_arr5 varchar(150) DEFAULT '1,2,3,5,1,2,3,5,1,2,3,5,1,2,3,5,1,2,3,4'; DECLARE event_arr6 varchar(150) DEFAULT '1,2,3,5,1,2,3,5,1,2,3,5,1,2,3,5,1,2,3,5'; DECLARE retry_arr1 varchar(150) DEFAULT '1,1,1,1'; DECLARE retry_arr2 varchar(150) DEFAULT '1,1,1,1,2,2,2,2'; DECLARE retry_arr3 varchar(150) DEFAULT '1,1,1,1,2,2,2,2,3,3,3,3'; DECLARE retry_arr4 varchar(150) DEFAULT '1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4'; DECLARE retry_arr5 varchar(150) DEFAULT '1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5'; DECLARE retry_arr6 varchar(150) DEFAULT '1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5'; DECLARE event_arr varchar(150); DECLARE retry_arr varchar(150) ; DECLARE task_source_idVal INT; DECLARE i INT default 0; DECLARE arr_index_probability_distribution varchar(1000) default'1,1,1,1,1,1,1,1,1,1,2,2,2,2,3,3,4,4,5,6,''1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,''1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,''1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,''1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,'; DECLARE arr_index_key INT DEFAULT 0; DECLARE rand_time varchar(25) ; DECLARE arr_value_value varchar(1000); SET task_source_idVal = 3000001; WHILE task_source_idVal &lt;= 4000000 DO select 1 + (RAND() * 101) into arr_index_key; SELECT FROM_UNIXTIME( FLOOR((@s := UNIX_TIMESTAMP('2021-10-19 23:59:56')) + RAND() * (UNIX_TIMESTAMP('2021-10-14 23:59:59') - @s + 1) )) into rand_time ; SET arr_value_value = SUBSTRING_INDEX(arr_index_probability_distribution, ',', arr_index_key); SET arr_value_value = SUBSTRING_INDEX(arr_value_value, ',', -1); CASE arr_value_value WHEN '1' THEN SET event_arr = event_arr1; SET retry_arr = retry_arr1; WHEN '2' THEN SET event_arr = event_arr2; SET retry_arr = retry_arr2; WHEN '3' THEN SET event_arr = event_arr3; SET retry_arr = retry_arr3; WHEN '4' THEN SET event_arr = event_arr4; SET retry_arr = retry_arr4; WHEN '5' THEN SET event_arr = event_arr5; SET retry_arr = retry_arr5; WHEN '6' THEN SET event_arr = event_arr6; SET retry_arr = retry_arr6; ELSE BEGIN END; END CASE; call function_test(event_arr,retry_arr,task_source_idVal,rand_time); SET task_source_idVal = task_source_idVal + 1; SET i = i+1; END WHILE;END;//delimiter ;call proc_batch_insert();","categories":[],"tags":[]},{"title":"全局变量 局部变量的生命周期","slug":"全局变量-局部变量的生命周期","date":"2021-09-18T03:35:38.000Z","updated":"2021-09-18T03:39:00.215Z","comments":true,"path":"2021/09/17/全局变量-局部变量的生命周期/","link":"","permalink":"https://yiyayamaya.github.io/2021/09/17/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"先开个坑 起因是python中的一个例子 下面的代码运行完后driver(浏览器窗口)不加driver.quit()也会自己退出，可能是因为局部变量被回收了 1234567def create_driver(): driver=xxx if __name__ == \"__main__\": create_driver() 改成这样的全局就好了。 12345678driver=Nonedef create_driver(): global driver if __name__ == \"__main__\": create_driver()","categories":[],"tags":[]},{"title":"尝试自己编译clash顺便docker入门","slug":"尝试自己编译clash顺便docker入门","date":"2021-09-15T07:37:29.000Z","updated":"2021-09-15T09:23:52.560Z","comments":true,"path":"2021/09/15/尝试自己编译clash顺便docker入门/","link":"","permalink":"https://yiyayamaya.github.io/2021/09/15/%E5%B0%9D%E8%AF%95%E8%87%AA%E5%B7%B1%E7%BC%96%E8%AF%91clash%E9%A1%BA%E4%BE%BFdocker%E5%85%A5%E9%97%A8/","excerpt":"","text":"镜像是文件，容器是进程$ docker ps // 查看所有正在运行容器$ docker stop containerId // containerId 是容器的ID $ docker ps -a // 查看所有容器$ docker ps -a -q // 查看所有容器ID $ docker stop $(docker ps -a -q) // stop停止所有容器$ docker rm $(docker ps -a -q) // remove删除所有容器 查看所有镜像docker images docker run为镜像创建一个容器 可以利用 docker container start 命令，直接将一个已经终止（exited）的容器启动运行。","categories":[],"tags":[]},{"title":"mysql 分页","slug":"mysql-分页","date":"2021-09-07T09:49:53.000Z","updated":"2021-09-11T03:44:58.785Z","comments":true,"path":"2021/09/07/mysql-分页/","link":"","permalink":"https://yiyayamaya.github.io/2021/09/07/mysql-%E5%88%86%E9%A1%B5/","excerpt":"","text":"MySQL 百万级数据量分页查询方法及其优化 https://www.huaweicloud.com/articles/7cb1402c2d18baedfa12dd610ff2eaac.html 在使用Mybatis时，最头痛的就是写分页了，需要先写一个查询count的select语句，然后再写一个真正分页查询(limit)的语句https://blog.csdn.net/Agly_Clarlie/article/details/53185750猜想结合pagehelper会容易 但是怎么结合呢？ 有前端的从前端发送pageNum pageSize的我会 name无前端的呢 无前端 单纯想要批量查询 结合pagehelper如何使用 ?参考了这个https://blog.csdn.net/a_c_c_a/article/details/106060621 可以通过pageInfo.getPages()得到总页数 结束pageNum的遍历 123456789101112131415161718192021int pageNum = 1;int pageSize =500;while(true) &#123; PageHelper.startPage(pageNum, pageSize); // TODO 不count的话下面就得不到pageInfo.getTotal() List&lt;Machine&gt; machineListPart = machineDao.getMachineAll(); PageInfo&lt;Machine&gt; pageInfo = new PageInfo&lt;&gt;(machineListPart); System.out.println( \" 当前页数[\"+pageNum +\"],页大小[\"+pageInfo.getPageSize() +\"],总页数[\"+pageInfo.getPages() +\"],总记录数[\"+pageInfo.getTotal()+\"]\" ); if(pageInfo.getPageNum()&gt;=pageInfo.getPages())&#123; break; &#125; pageNum++;&#125; 1234567891011121314151617网元参数迁移 当前页数[1],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[2],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[3],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[4],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[5],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[6],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[7],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[8],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[9],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[10],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]...网元参数迁移 当前页数[100],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[101],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[102],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[103],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[104],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]网元参数迁移 当前页数[105],页大小[10000],当页大小[376],总页数[105],总记录数[1040376] 但是上述pagehelper也是通过limit简单实现 可以利用索引 123456789101112int pageIdIndex=0; int pageSize=100; int totalNum=machineDao.getMachineNum(); while(true) &#123; List&lt;Machine&gt; machineListPart = machineDao.getMachineAllBetter(pageIdIndex,pageSize); pageIdIndex+=pageSize; if (pageIdIndex&gt;totalNum) break; &#125; 未完待续","categories":[],"tags":[]},{"title":"java中super()的用法","slug":"java中super-的用法","date":"2021-09-07T06:53:32.000Z","updated":"2021-09-07T07:08:41.047Z","comments":true,"path":"2021/09/07/java中super-的用法/","link":"","permalink":"https://yiyayamaya.github.io/2021/09/07/java%E4%B8%ADsuper-%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"va继承中，经常会碰上super()方法，今天恰好碰上，小小的研究了一下。 super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 在子类的构造方法的第一行，必须是第一行调用super()，这样就调用了父类的构造方法，如果父类有多个不同的构造方法，则根据调用super()时传入的参数调 顺便记录下关于Java继承中构造方法的一些东西：在调用子类构造方法时，不管调用的是有参还 是无参，如果没有在第一行调用super(var xx)，都会默认先调用父类的无参构造方法。","categories":[],"tags":[]},{"title":"$.post可以说是缩写版的$.ajax","slug":"post可以说是缩写版的-ajax","date":"2021-08-24T08:07:02.000Z","updated":"2021-08-24T08:11:07.455Z","comments":true,"path":"2021/08/24/post可以说是缩写版的-ajax/","link":"","permalink":"https://yiyayamaya.github.io/2021/08/24/post%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E7%BC%A9%E5%86%99%E7%89%88%E7%9A%84-ajax/","excerpt":"","text":"石锤了 官方说法 总忘 水了一篇文章","categories":[],"tags":[]},{"title":"mysql 外键 ON DELETE CASCADE","slug":"mysql-外键-ON-DELETE-CASCADE","date":"2021-08-24T06:35:34.000Z","updated":"2021-08-24T06:47:20.430Z","comments":true,"path":"2021/08/24/mysql-外键-ON-DELETE-CASCADE/","link":"","permalink":"https://yiyayamaya.github.io/2021/08/24/mysql-%E5%A4%96%E9%94%AE-ON-DELETE-CASCADE/","excerpt":"","text":"https://www.yiibai.com/mysql/foreign-key.html https://www.yiibai.com/mysql/on-delete-cascade.html 假设有两张表：建筑物(buildings)和房间(rooms)。 在这个数据库模型中，每个建筑物都有一个或多个房间。 然而，每个房间只属于一个建筑物。没有建筑物则房间是不会存在的。 当我们从buildings表中删除一行时，还要删除rooms表中引用建筑物表中行的行。 我们希望rooms表中涉及到建筑物编号2的行记录也将被删除(讲得通俗一点：假设2号楼倒塌了，那么2号楼的房间应该也就不存在了)。以下是演示MySQL ON DELETE CASCADE参考操作如何工作的步骤。 12345678910USE testdb;CREATE TABLE rooms ( room_no INT PRIMARY KEY AUTO_INCREMENT, room_name VARCHAR(255) NOT NULL, building_no INT NOT NULL, FOREIGN KEY (building_no) REFERENCES buildings (building_no) ON DELETE CASCADE)ENGINE=InnoDB DEFAULT CHARSET=utf8; 为何说外键有性能问题：1.数据库需要维护外键的内部管理；2.外键等于把数据的一致性事务实现，全部交给数据库服务器完成；3.有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源；4.外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；","categories":[],"tags":[]},{"title":"一次前端父页面向子页面传值的思考","slug":"一次前端父页面向子页面传值的思考","date":"2021-08-24T05:42:15.000Z","updated":"2021-08-24T05:52:01.731Z","comments":true,"path":"2021/08/24/一次前端父页面向子页面传值的思考/","link":"","permalink":"https://yiyayamaya.github.io/2021/08/24/%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AF%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%90%91%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"点开的新窗口的一个值是从父页面传进子页面的值而不是子页面异步获取的这种东西通常不能在子里面修改 如果嗯要修改一、需要刷新父刷新父亲的两种方法1.reload 2.不reload 单纯改值二、要么不要传 用子异步请求","categories":[],"tags":[]},{"title":"jquery 学习","slug":"jquery-学习","date":"2021-08-22T06:04:01.000Z","updated":"2021-08-23T03:57:21.316Z","comments":true,"path":"2021/08/22/jquery-学习/","link":"","permalink":"https://yiyayamaya.github.io/2021/08/22/jquery-%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"jquery 对象 vs dom对象用#id作为选择符取得的是jQuery对象与document.getElementById(“id”)得到的DOM对象，这两者并不等价。 (一)jQuery对象是一个数据对象，可以通过[index]的方法，来得到相应的DOM对象。例： var $v =$(“#v”) ; //jQuery对象 var v=$v[0]; //DOM对象 alert(v.checked) //检测这个checkbox是否被选中 var $email = $(“#email”); // refers to the jQuery object representation of the dom objectvar email_field = $(“#email”).get(0); // refers to the dom object itself 仅仅是变量名的一种规范 注：jquery对象命名时，通常以$开头，比如 var $ps = $(‘p’)，这样的好处是，一眼就知道$ps是一个jquery对象，程序可读性大大提高。————————————jquery选择器返回多个还是一个 一、当使用id选择器时，会返回对应的jquery对象 let files = $(“#uploadFile_batchImport”);let file = files[0].files[0];以上代码中，files是jquery对象，files[0]是dom元素，file则是dom元素的files属性的第一个文件。二、当使用类选择器时，返回的是多个dom对象组成的jquery对象let obj = $(“.intro”); let aDom = obj[0]; 此时，obj是多个dom元素组成的jquery对象，aDom是个dom对象。 [attribute] $(“[href]”) 具有href属性的所有元素 [attribute=value] $(“[href=’default.htm’]”) href属性值等于“default.htm”的所有元素 $(“p”) 选取 元素。 $(“p.intro”) 选取所有 class=”intro” 的 元素。 $(“p#demo”) 选取所有 id=”demo” 的 元素。 jQuery 使用 XPath 表达式来选择带有给定属性的元素。 $(“[href]”) 选取所有带有 href 属性的元素。 $(“[href=’#’]”) 选取所有带有 href 值等于 “#” 的元素。 $(“[href!=’#’]”) 选取所有带有 href 值不等于 “#” 的元素。 $(“[href$=’.jpg’]”) 选取所有 href 值以 “.jpg” 结尾的元素。 按tag查找 按class查找 按属性查找 组合查找 多项选择器 层级选择器（Descendant Selector）如果两个DOM元素具有层级关系，就可以用$(‘ancestor descendant’)来选择，层级之间用空格隔开。例如： 子选择器（Child Selector） .find().parent()方法 parent()是唯一的，为什么可以加selector呢？本方法也可以接受一个字符串选择器，用于筛选返回的元素。 本方法用于选择给定jQuery对象中包含的DOM元素或者DOM元素集的祖先节点，并将这些节点包装成jQuery对象返回，返回的节点集是以从里到外的顺序排序的。 parents()同理 这里我们看到有一个prevObject，这个this.prevObject到底是用来干什么的呢？没错，jQuery通过这个属性维护了一个jQuery对象栈，只要我们使用选择相关的方法（如find()，eq()等）获取新的jQuery对象，jQuery就会把之前的对象存储在prevObject中。","categories":[],"tags":[]},{"title":"form表单中button type是button而不是submit","slug":"form表单中button-type是button而不是submit","date":"2021-08-12T01:41:34.000Z","updated":"2021-08-24T06:03:07.117Z","comments":true,"path":"2021/08/11/form表单中button-type是button而不是submit/","link":"","permalink":"https://yiyayamaya.github.io/2021/08/11/form%E8%A1%A8%E5%8D%95%E4%B8%ADbutton-type%E6%98%AFbutton%E8%80%8C%E4%B8%8D%E6%98%AFsubmit/","excerpt":"","text":"遇到了一个需求和这个楼主一抹一样。 https://segmentfault.com/q/1010000005039644 因为是通过ajax请求服务器来实现登录的，所以我没有用button type=”submit”，但是现在问题是如果type是button的话，就不能实现敲回车自动触发按钮的功能了，我想做到在输入框里敲一下回车就自动触发登录的功能，请问该如何实现啊？ 换回 type=”submit”，在 form 的 onsubmit 事件中触发 AJAX 请求，并 event.preventDefault() 就可以了。 顺便看到了一篇白话解释 Javascript事件preventDefault,stopPropagation及return false的区别https://segmentfault.com/a/1190000008227026讲得很好。提到了一下javascript中两种事件传播模式:捕获模式(capturing)冒泡模式(bubbling)","categories":[],"tags":[]},{"title":"通过一次线上问题排查内存过大来学习jvm基础","slug":"通过一次线上问题排查内存过大来学习jvm基础","date":"2021-07-29T06:31:35.000Z","updated":"2021-08-02T08:26:35.699Z","comments":true,"path":"2021/07/29/通过一次线上问题排查内存过大来学习jvm基础/","link":"","permalink":"https://yiyayamaya.github.io/2021/07/29/%E9%80%9A%E8%BF%87%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E8%BF%87%E5%A4%A7%E6%9D%A5%E5%AD%A6%E4%B9%A0jvm%E5%9F%BA%E7%A1%80/","excerpt":"","text":"用到的工具 jmap jstack jvisualvm现在叫visualVM MAT JConsole 生成的dump文件可以用jhat分析 jmap命令将程序的内存数据保存下来，jmap -dump:live,format=b,file=m.hprof PID 然后我指着监控信息，让运维看：“大哥你看这监控历史，堆内存是达到过 6G 的，只是后面 GC 了，没问题啊！” “JVM 的垃圾回收，只是一个逻辑上的回收，回收的只是 JVM 申请的那一块逻辑堆区域，将数据标记为空闲之类的操作，不是调用 free 将内存归还给操作系统” JVM 的自动内存管理，其实只是先向操作系统申请了一大块内存，然后自己在这块已申请的内存区域中进行“自动内存管理”。JAVA 中的对象在创建前，会先从这块申请的一大块内存中划分出一部分来给这个对象使用，在 GC 时也只是这个对象所处的内存区域数据清空，标记为空闲而已 运维：“原来是这样，那按你的意思，JVM 就不会将 GC 回收后的空闲内存还给操作系统了吗？” JVM 还是会归还内存给操作系统的，只是因为这个代价比较大，所以不会轻易进行。而且不同垃圾回收器 的内存分配算法不同，归还内存的代价也不同。 java加jvm参数正确格式应该是nohup java -Xms800m -Xmx800m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxNewSize=512m -jar 你的jar包 &gt;&gt;/dev/null &amp; 1234567891011121314151617181920212223242526272829303132&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_131&#x2F;bin&#x2F;java -jar -server -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;dump&#x2F;heap&#x2F; -Djava.io.tmpdir&#x3D;&#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;tmp&#x2F; -Dserver.port&#x3D;8103 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port&#x3D;5103 -Dcom.sun.management.jmxremote.rmi.port&#x3D;6103 -Dcom.sun.management.jmxremote.authenticate&#x3D;false -Dcom.sun.management.jmxremote.ssl&#x3D;false -Dcom.sun.management.jmxremote.access.file&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;management&#x2F;jmxremote.access -Xmx2G -Xms2G -XX:+DisableExplicitGC -verbose:gc -Xloggc:&#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;log&#x2F;gc.%t.log -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTaskTimeStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Dserver.connection-timeout&#x3D;60000 -Dserver.tomcat.accept-count&#x3D;1000 -Dserver.tomcat.max-threads&#x3D;300 -Dserver.tomcat.min-spare-threads&#x3D;65 -Dserver.tomcat.accesslog.enabled&#x3D;false -Dserver.tomcat.accesslog.directory&#x3D;&#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;log&#x2F; -Dserver.tomcat.accesslog.prefix&#x3D;access_log -Dserver.tomcat.accesslog.pattern&#x3D;combine -Dserver.tomcat.accesslog.suffix&#x3D;.log -Dserver.tomcat.accesslog.rotate&#x3D;true -Dserver.tomcat.accesslog.rename-on-rotate&#x3D;true -Dserver.tomcat.accesslog.request-attributes-enabled&#x3D;true -Dserver.tomcat.accesslog.buffered&#x3D;true -XX:NewRatio&#x3D;4 -XX:SurvivorRatio&#x3D;30 -XX:TargetSurvivorRatio&#x3D;90 -XX:MaxTenuringThreshold&#x3D;8 -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction&#x3D;70 -XX:ParallelGCThreads&#x3D;24 -XX:ConcGCThreads&#x3D;24 -XX:-UseGCOverheadLimit -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction&#x3D;1 -XX:+CMSParallelRemarkEnabled -XX:+CMSScavengeBeforeRemark -XX:+ParallelRefProcEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSMaxAbortablePrecleanTime&#x3D;6000 -XX:CompileThreshold&#x3D;10 -XX:MaxInlineSize&#x3D;1024 -Dsun.net.client.defaultConnectTimeout&#x3D;60000 -Dsun.net.client.defaultReadTimeout&#x3D;60000 -Dnetworkaddress.cache.ttl&#x3D;300 -Dsun.net.inetaddr.ttl&#x3D;300 -Djsse.enableCBCProtection&#x3D;false -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -Dfile.encoding&#x3D;UTF-8 -Dlog.path&#x3D;&#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;log&#x2F; -Dspring.profiles.active&#x3D;online &#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;deploy&#x2F;zcmweb.jar zcmweb 最后xxx.jar 后面加–spring.config.location jmap指定-heap：打印jvm heap的情况-histo：打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。-histo:live ：同上，但是只答应存活对象的情况-permstat：打印permanent generation heap情况 jmap -histo 18473 | head -30jmap -histo 18473 | tail -30 /home/wxj/Documents/Hexo-source-files/source/_posts/通过一次线上问题排查内存过大来学习jvm基础/2021-07-30_11-41.png 从打印结果可看出，类名中存在[C、[B等内容，只知道它占用了那么大的内存，但不知道由什么对象创建的。下一步需要将其他dump出来，使用内存分析工具进一步明确它是由谁引用的、由什么对象。 Heap Dump 是Java进程所使用的内存情况在某一时间的一次快照。 以文件的形式持久化到磁盘中。 分析dump文件的几种方式1、visualVM2、MAT3、jhat 15397.hprof (去localhost:7000查看) 插入内容：JDK命令行（jps、jstat、jinfo、jmap、jhat、jstack、jstatd、hprof）与JConsolehttps://www.huaweicloud.com/articles/9871161f404d4e817e18db0f40e815a1.html 看本身大小时，占大头的都是char[] ,byte[]之类的，没什么意思（用jmap -histo:live pid 看的也是本身大小）。所以需要关心的是保留大小比较大的对象，看谁在引用这些char[], byte[]。 (MAT能看的信息更多，但VisualVM胜在JVM自带，用法如下：命令行输入jvisualvm，文件-&gt;装入-&gt;堆Dump－&gt;检查 -&gt; 查找20保留大小最大的对象，就会触发保留大小的计算，然后就可以类视图里浏览，按保留大小排序了) 可以从这个图看出这个类java.lang.ref.Finalizer占用500多M，表示这其中很多不能够被回对象的对象，此时点开hisgogram视图，并通过Retained Heap进行排序，如下截图： 从图中可以看出，被线线框圈起来的三个对象占用量非常大，那说明这几个大的对象并没有被释放，那现在就可以有针对性的从代码中去找这几个对象为什么没有被释放了。再切换到dominator_tree视图： 这里可以看到velocity渲染也存在着问题，以及数据库的请求也比较多。 https://blog.51cto.com/supercharles888/1347144 讲了shallow size Retained size区别Shallow Size是对象本身占据的内存的大小，不包含其引用的对象。对于常规对象（非数组）的Shallow Size由其成员变量的数量和类型来定，而数组的ShallowSize由数组类型和数组长度来决定，它为数组元素大小的总和。 Retained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C,C就是间接引用) ，并且排除被GC Roots直接或者间接引用的对象 Incoming references被什么实例引用了 和 Outgoing references引用了什么实例 一般来说，如果浅堆比较小，但是深堆比较大，那么这种对象比较可疑，首先找到深堆大的对象，然后通过incoming查看哪些对象引用这个对象，通过outgoing查看这个对象内部都有哪些对象 不确定这行写的对：dominator_tree中这两个值与Histogram中的区别是：dominator_tree基于实例的角度，而historgram基于类的角度 X86是一种架构，但是他有32位的和64位的！32位的叫x86 ，后来出现基于它的64位版，就叫X86-64，后来有时简称X64。 Histogram是类粒度的，可以找到哪个类占用的堆内存比较多；dominator tree是对象粒度的，可以用来查看哪个对象引起占用堆内存比较大。选择dominator tree以后可以 group by class 就能按class看了！！！但是可能是因为unreachable 的原因，数目对不上。 升级版 JConsole 即 jvisualvm 。","categories":[],"tags":[]},{"title":"java 多线程学习","slug":"java-多线程学习","date":"2021-07-22T03:28:26.000Z","updated":"2021-07-26T06:06:17.329Z","comments":true,"path":"2021/07/21/java-多线程学习/","link":"","permalink":"https://yiyayamaya.github.io/2021/07/21/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"先看廖雪峰https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。 一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。 改看王道的os了https://www.bilibili.com/video/BV1YE411D7nH?p=8进程由程序段数据段PCB三部分组成 寄存器与内存的区别 load某内存地址的值放入某寄存器aload某内存地址的值放入某寄存器b运算a+b结果放到寄存器c把寄存器c的值保存到某内存(存放运算结果) 1.如果是说有没有一条指令可以完成读内存 计算 再把结果写回内存 那显然是有的。x86的运算指令就可以用内存数据当运算对象 如果是更lower level一点 对于微指令 绝大部分情况下是没有直接在内存数据上计算的. 通常应该是用load把内存数据都到register 然后在register上进行运算。对于risc来说, 这些每一个操作其实大都是一条汇编指令 先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。 但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。 https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html阮一峰写的 堆内存栈内存什么的 挺好的 数据结构中的堆和内存中的堆是两个完全不同的概念 1234int main() &#123; int a = 2; int b = 3;&#125; 123456int main() &#123; int a = 2; int b = 3; return add_a_and_b(a, b);&#125; stack memory 个人理解：因为其后进先出的方式得到了stack这样的名字，另一个内存会在函数退出时自动且非常有效地回收。Stack 是由于函数运行而临时占用的内存区域。上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。 基于堆的内存分配，也称为动态内存分配。程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。比如新建对象，或者使用malloc命令。从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。 (不一定对)一般来说，每个线程分配一个stack，每个进程分配一个heap。 操作系统帧frame是什么 核心态 用户态 pv操作 王道考研操作系统 三层调度没听懂 单标志法 忙等待：指在单CPU情况下，一个进程进入临界区之后，其他进程因无法满足竞争条件而循环探测竞争条件。其缺点是，在单CPU情况下，等待进程循环探测竞争条件，浪费了时间片。 为什么生产者消费者的两个p操作不能换 实现互斥的p操作要放在实现同步的p操作之后。两个v操作顺序可以交换 多消费者 吸烟者问题没听懂 github上XvTianYuan翻译的操作系统恐龙书第十版。线程时CPU利用的基本单元；它包含一个线程ID，程序计数器(PC)，一个寄存器集(寄存器不是在cpu里么)和栈。一个线程与其他属于同一个进程的线程共享代码段和操作系统资源，如打开的文件和信号。","categories":[],"tags":[]},{"title":"java synchronized","slug":"java-synchronized","date":"2021-07-13T06:36:29.000Z","updated":"2021-10-15T09:54:50.274Z","comments":true,"path":"2021/07/13/java-synchronized/","link":"","permalink":"https://yiyayamaya.github.io/2021/07/13/java-synchronized/","excerpt":"","text":"当一个线程访问同步代码块时，首先是需要得到锁才能执行 其实“锁”本身是个对象，synchronized这个关键字并不是“锁”。从语法上讲，Java中的每个对象都可以看做一把锁，在HotSpot JVM实现中，锁有个专门的名字：监视器（Monitor）。Monitor对象存在于每个Java对象的对象头中，这也是为什么Java中任意对象可以作为锁的原因，有关Monitor后续会详细介绍，有了这些概念看下面这张图应该就容易多了。 一个对象中有两个实例方法同时被synchronized，则同一个对象，调用这两个方法时，只能同时执行一个。原因：翻看相关书籍，发现jvm在执行方法以前，如果发现该方法前面有对象的synchronized关键字，就现在该对象的ID上加锁，当其他线程执行同时执行这个方法时，会检测改对象ＩＤ上是否加锁，如果加锁时就等待锁释放。 Java Thread acquires an object level lock when it enters into an instance synchronized java method and acquires a class level lock when it enters into static synchronized java method. 如果是静态的方法呢？https://stackoverflow.com/questions/15438727/if-i-synchronized-two-methods-on-the-same-class-can-they-run-simultaneously静态方法使用.class上的锁。如果class A {static synchronized void m() {} }，然后 new A().m()会锁住新的A()对象，此时别人调用A.m()需要的是A.class的锁但现在没有这样的锁，所以不会互相阻塞。所以永远不要实例化对象来调用静态方法。Have in mind that static methods use lock on .class object. So if you have class A {static synchronized void m() {} }. And then one thread calls new A().m() it acquires lock on new A() object. If then another thread calls A.m() it ENTERS THE METHOD NO PROBLEM because what it looks for is lock on A.class object while NO THREADS possess this kind of lock. So even though you declared method synchronized it actualy IS accessed by two different threads AT THE SAME TIME. Thus: never use object references to call static methods Putting synchronized on an instance method means that the thread has to acquire the lock (the “intrinsic lock”) on the object instance that the method is called on before the thread can start executing any code in that method.把synchronized放一个实例方法上意味着，该线程必须获取关于对象实例锁（以下简称“本征锁”），该方法被调用之前线程可以开始在该方法中执行的任何代码。 5:35 PM Friday, October 15, 2021更新 有一个单例类FTPClientUtils里面全是静态方法 123456789101112131415public class FTPClientUtils &#123; public static synchronized void getInstance() public static synchronized void switchToDir() public static synchronized void getOutputStream() public static synchronized void Upload() public static synchronized void finish()&#125; 有一个Service里有一个上传文件的方法 123456789public void upload()&#123; FTPClientUtils.getInstance();//确认ftpclient实例可用 FTPClientUtils.switchToDir();//切换至目录 FTPClientUtils.getOutputStream();//创建文件流 FTPClientUtils.UploadStream();//传输流 FTPClientUtils.finishStream();//切断文件流&#125; 所有静态方法都在竞争同一个class锁 问题是：如果在Upload()过程中，执行其他方法。在Upload()结束后放下锁，希望finish()立刻得到锁，结果被外面的getInstance()抢到了，又因为没关闭的文件流导致getInstance()阻塞，造成了死锁。 解决办法一：把service中的upload()加代码块锁 1234567891011public void upload()&#123; synchronized(FTPClientUtils.class)&#123; FTPClientUtils.getInstance();//确认ftpclient实例可用 FTPClientUtils.switchToDir();//切换至目录 FTPClientUtils.getOutputStream();//创建文件流 FTPClientUtils.UploadStream();//传输流 FTPClientUtils.finishStream();//切断文件流 &#125;&#125; 解决办法二：在FTPClientUtils中新建一个静态加锁方法，并把五个方法五合一。 1234567891011121314151617181920212223public class FTPClientUtils &#123; public static synchronized void getInstance() public static synchronized void switchToDir() public static synchronized void getOutputStream() public static synchronized void Upload() public static synchronized void finish() public static synchronized void upload()&#123; getInstance(); switchToDir(); getOutputStream(); Upload(); finish(); &#125;&#125;","categories":[],"tags":[]},{"title":"java 异常","slug":"java-异常","date":"2021-07-12T05:54:22.000Z","updated":"2021-11-29T05:59:01.268Z","comments":true,"path":"2021/07/12/java-异常/","link":"","permalink":"https://yiyayamaya.github.io/2021/07/12/java-%E5%BC%82%E5%B8%B8/","excerpt":"","text":"我怎么隐隐约约觉得写过异常相关的文章 但是找不到了。 Error是内存不足这种。 Exception：分为未检查异常(RuntimeException)和已检查异常(非RuntimeException) checkedException ：受检查的异常，这种异常是强制我们catch或方法声明throws的异常。如果不处理，编译器会报错。计的目的是为了提醒开发者处理一些场景中必然可能存在的异常情况。比如IOException RuntimeException：运行时异常，这种异常我们不需要处理，完全由虚拟机接管。比如我们常见的NullPointerException，我们在写程序时不会进行catch或throw。 17:33, November 17, 2021 更新 A调用B，B调用C。C声明的throws继续向上。B也需要声明throws。 14:29, November 26, 2021 更新@SneakyThrows aurora beach bitday chihuahuan cliffs colony desert earth exodus factory firewatch forest gradient home island lake lakeside market mojave moon mountains room sahara street tokyo","categories":[],"tags":[]},{"title":"mysql 索引什么时候更新","slug":"mysql-索引什么时候更新","date":"2021-07-09T03:47:23.000Z","updated":"2021-07-09T03:51:42.035Z","comments":true,"path":"2021/07/08/mysql-索引什么时候更新/","link":"","permalink":"https://yiyayamaya.github.io/2021/07/08/mysql-%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%9B%B4%E6%96%B0/","excerpt":"","text":"https://stackoverflow.com/questions/17282041/when-does-mysql-update-the-indexes 索引更新有两个方面。 第一部分是在索引中插入/更新/删除条目。一旦记录更改，索引就会更新，并且此过程会阻止查询直到完成。这允许基于索引列上的条件更快地检索记录，这是索引最容易理解的目的。 第二部分是更新索引的统计信息。这允许优化器确定对于给定查询是否值得使用索引。更新不会自动进行。这些统计数据应定期手动更新ANALYZE TABLE [table_name]。 https://www.bilibili.com/video/BV12b411K7Zu?p=209 mysql尚硅谷视频 跳着看的 看到p209","categories":[],"tags":[]},{"title":"mysql 索引选择的原理—优化器","slug":"mysql-索引选择的原理—优化器","date":"2021-07-09T03:35:55.000Z","updated":"2021-07-09T03:52:13.435Z","comments":true,"path":"2021/07/08/mysql-索引选择的原理—优化器/","link":"","permalink":"https://yiyayamaya.github.io/2021/07/08/mysql-%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E7%9A%84%E5%8E%9F%E7%90%86%E2%80%94%E4%BC%98%E5%8C%96%E5%99%A8/","excerpt":"","text":"https://blog.csdn.net/weixin_39846186/article/details/113370118 选择索引是mysql决定的写 SQL 语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由 MySQL 来确定的。有这种情况，一条本来可以执行得很快的语句，却由于 MySQL 选错了索引，而导致执行速度变得很慢。 将慢查询日志的阈值设置为 0，表示这个线程接下来的语句都会被记录入慢查询日志中set long_query_time=0; 选择索引是mysql的优化器的工作，主要依据扫描行数。选择索引是优化器的工作。而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。 扫描行数是怎么判断的MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”(cardinality)。也就是说，这个基数越大，索引的区分度越好。","categories":[],"tags":[]},{"title":"java同步试水","slug":"java同步试水","date":"2021-07-06T07:57:20.000Z","updated":"2021-07-07T08:33:05.004Z","comments":true,"path":"2021/07/06/java同步试水/","link":"","permalink":"https://yiyayamaya.github.io/2021/07/06/java%E5%90%8C%E6%AD%A5%E8%AF%95%E6%B0%B4/","excerpt":"","text":"今天遇到个需求，可能有同时两个方法写入同一个excel。 怎么能让一个方法同时被调用，创建线程就行了 为什么用匿名内部类的形式创建thread及两种实现多线程的基本方式 static不能向上抛出异常了 即使不是static，实现Runnable接口不能抛异常只能捕获异常 main里不能访问实例方法，只能静态方法 java中方法必须写在类体里 为什么要向上转型而不是直接声明子类引用（Dog dog=new Dog()）？ 怎么能让一个方法同时被调用，创建线程就行了首先是一个方法被同时调用，开始我还不会怎么能让一个方法被同时执行。后来搜到创建线程就行了。需要同时执行的方法像下面createExcelFile()这样 123456789101112131415161718192021222324public synchronized static void createExcelFile(String excelPath) throws IOException &#123; if (!excelFileExisted) &#123;//false可能是1.没文件没布尔;2.有文件没布尔 File file = new File(excelPath); if (file.createNewFile()) &#123;//没文件没布尔 System.out.println(\"文件创建成功\"); XSSFWorkbook workbook = new XSSFWorkbook(); FileOutputStream outputStream = new FileOutputStream(excelPath); workbook.write(outputStream); outputStream.close(); &#125; else &#123;//有文件没布尔 &#125; excelFileExisted = true; &#125; else &#123; System.out.println(\"文件已经存在.\"); &#125;&#125; new Thread长这样 123456Thread threadOne = new Thread(new Runnable() &#123; @SneakyThrows public void run() &#123; createExcelFile(excelPath); &#125; &#125;); 为什么用匿名内部类的形式创建thread及两种实现多线程的基本方式本来向main里抛出异常，main直接调用createExcelFile()没啥事但是，这么创建thread就报错了，加了@SneakyThrows就行了。为什么呢？大概是因为thread是以内部类形式创建的。(那我现在去看下内部类https://www.cnblogs.com/dolphin0520/p/3811445.html )发现有成员内部类 局部内部类 匿名内部类。这个属于匿名内部类。不对啊 虽然下面这种形式也是可以的，但是还是要加@SneakyThrow，为什么呢？ 12345678910111213static class Runnable1 implements Runnable&#123; @SneakyThrows public void run() &#123; createExcelFile(excelPath); createSheetAndTitle(excelPath, machineSheetName, titles); ArrayList&lt;String[]&gt; list = new ArrayList&lt;String[]&gt;(); list.add(new String[]&#123;\"1\", \"F:0.756\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())&#125;); list.add(new String[]&#123;\"1\", \"E:0.933\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())&#125;); addRows(excelPath, machineSheetName, list); &#125; &#125; 这种写法虽然能达到一样的效果，但是既冗长又难以维护。那么问题来了，使用匿名内部类创建线程的好处是什么？但是，如果一个只使用一次，那么将其编写为独立的一个类岂不是很麻烦？这个时候就应该想到匿名内部类了，匿名内部类就此诞生了！不得不说匿名方法最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口。首先，多线程的实现方式两种：一种是继承Thread类，另一种是实现Runnable接口。Thread类是Runnable接口的一个实现类看两种实现多线程的基本方式(不实用匿名内部类) 继承Thread： 1234567891011121314151617181920class MyThread extends Thread&#123; private int ticket = 5; public void run()&#123; for(int i = 0;i&lt;100;i++)&#123; if(ticket&gt;0)&#123;//判断是否还有剩余票 System.out.println(\"卖票,ticket = \"+ticket--); &#125; &#125; &#125;&#125;;public class ThreadDemo04&#123; public static void main(String args[])&#123; MyThread mt1 = new MyThread(); MyThread mt2 = new MyThread(); MyThread mt3 = new MyThread(); mt1.start();//调用线程主体让其运行 mt2.start();//三个地方同时卖票 mt3.start(); &#125;&#125;; 实现Runnable： 123456789101112131415161718class MyThread implements Runnable&#123; private int ticket=5; public void run()&#123; for(int i = 0;i&lt;100;i++)&#123; if(ticket&gt;0)&#123; System.out.println(\"卖票,ticket = \"+ticket--); &#125; &#125; &#125;&#125;;public class RunnableDemo02&#123; public static void main(String args[])&#123; MyThread my1 = new MyThread(); new Thread(my1).start(); //启动三个线程 new Thread(my1).start(); //共享my1中资源 new Thread(my1).start(); &#125;&#125;; 可知最后：无论哪种方法都需要实现run()方法，run方法是线程的运行主体。并且，线程的运行都是调用Thread的start()方法。那么代理模式中Thread类就充当了代理类，它在线程运行主体运行前作了一些操作然后才运行线程的run()。总之，Thread提供了很多有关线程运行前、后的操作，然后通过它的start()方法让JVM自动调用目标的run()方法。 static不能向上抛出异常了之前的问题为什么不能向上抛出呢？跟匿名内部类没有一点关系是因为静态代码块中的异常原则上必须处理,不应该也不能再往上抛原因:在类加载器，加载该类时，首先执行的就是static{}块中的代码,如果static{}块中的异常没有处理，异常就会导致该类加载失败,也就是说“该类夭折，不存在”,显然与其相关的操作肯定就不能执行当然了，如果你“不得不”向外抛可以这样写:(用InputStream举例，可根据你自己的代码修改一下)https://bbs.csdn.net/topics/310071083 12345678static &#123; try &#123; InputStream inputStream = new FileInputStream(\"\"); &#125; catch (FileNotFoundException e) &#123; // 抛出 运行式异常 (这样写，实质上也应该算是处理了异常) throw new RuntimeException(e); &#125; &#125; 即使不是static，实现Runnable接口不能抛异常只能捕获异常我去掉static发现还是不能抛，为什么？因为run()方法是Runnable接口里面的方法,而Runnable接口在定义run()方法的时候没有抛出任何异常,所以子类在重写run()方法的时候要小于或等于父类(Runnable)的run()方法的异常,所以父类没有抛出异常,子类不能抛出异常 那我上面说的static不能抛到底是不是对的啊？好像完全没有问题啊。static方法完全可以抛出异常啊。那上一段我就划掉了。 main里不能访问实例方法，只能静态方法顺便插一嘴因为main是static，所以不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。 java中方法必须写在类体里再顺便插一嘴，java中方法必须写在类体里。我他妈居然才知道。 为什么要向上转型而不是直接声明子类引用（Dog dog=new Dog()）？比如设计一个父类 FileRead 用来读取文件，ExcelRead 类和 WordRead 类继承 FileRead 类。在使用程序的时候，往往事先不知道我们要读入的是 Excel 还是 Word。所以我们向上转型用父类去接收，然后在父类中实现自动绑定，这样无论你传进来的是 Excel 还是 Word 就都能够完成文件读取。 下面两篇关于为什么不要声明子类引用讲得挺好的 内容差不多 忘了多看看。https://blog.csdn.net/TNTZS666/article/details/80273986http://c.biancheng.net/view/6521.html 可是我试了试上面说的，发现纯属放屁。 1234567891011121314151617181920212223public static void show(ADCarry adCarry) &#123; adCarry.duiXian(); adCarry.faYu(); &#125; public static void main(String[] args) &#123; ADCarry uzi2 = new Uzi(); show(uzi2);//正确 Uzi uzi = new Uzi(); show(uzi);//你他妈怎么也正确啊 ; &#125;","categories":[],"tags":[]},{"title":"classpath到底是个什么玩意","slug":"classpath到底是个什么玩意","date":"2021-07-02T09:58:27.000Z","updated":"2021-07-06T01:03:50.487Z","comments":true,"path":"2021/07/02/classpath到底是个什么玩意/","link":"","permalink":"https://yiyayamaya.github.io/2021/07/02/classpath%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E7%8E%A9%E6%84%8F/","excerpt":"","text":"先开个坑，我大一初学java被环境配置严重劝退，现在也仅仅是会配，但是不懂为什么要这么配。有空我要把这个问题搞懂。python Run.py 与 python /home/path/Run.py 执行结果是不一样的因为在执行的过程中，命令行默认只是搜索当前执行路径，所以会导致一部分引用的模块找不到 log","categories":[],"tags":[]},{"title":"有关git分支看到的不错的一个回答","slug":"有关git分支看到的不错的一个回答","date":"2021-07-01T05:56:03.000Z","updated":"2021-07-02T08:21:15.561Z","comments":true,"path":"2021/07/01/有关git分支看到的不错的一个回答/","link":"","permalink":"https://yiyayamaya.github.io/2021/07/01/%E6%9C%89%E5%85%B3git%E5%88%86%E6%94%AF%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%8D%E9%94%99%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9B%9E%E7%AD%94/","excerpt":"","text":"开发时怎么用好 Git 分支? - Color的回答 - 知乎https://www.zhihu.com/question/21995370/answer/19975870 假如远程只有一个master本地分支可以不同步到远程仓库，我们可以在本地dev开发，然后merge到master，使用master同步代码 假如远程有自己的分支 推远程master的同时推远程dev 这样的意义是什么？git checkout dev # 切换到dev分支进行开发 开发代码之后，我们有两个选择 第一个：如果功能开发完成了，可以合并主分支 git checkout master # 切换到主分支 git merge dev # 把dev分支的更改和master合并 git push # 提交主分支代码远程 git checkout dev # 切换到dev远程分支 git push # 提交dev分支到远程 第二个：如果功能没有完成，可以直接推送 git push # 提交到dev远程分支 注意：在分支切换之前最好先commit全部的改变，除非你真的知道自己在做什么 还有一篇文章 写的不错 关于merge和rebase配合使用 https://zhuanlan.zhihu.com/p/34197548 例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 git rebase master 等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 git merge dev rebase类型操作git checkout B1git pull origin B1 –rebasegit rebase mastergit push origin B1 –force vs我以前的merge操作 (这里为什么要merge两次 先master into B1 再B1 into master 其实我不懂 这个问题似乎得到了解答 )git checkout B1git pull origin B1git merge mastergit push origin B1 上面两个之后都要git checkotu mastergit merge B1 Git push 时如何避免出现 “Merge branch ‘master’ of …”https://www.cnblogs.com/Sinte-Beuve/p/9195018.html A-B-C(master) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D(origin/master) 我当前拉取的远端版本为 B，此时修改了代码，并在本地仓库 commit 一次，但并未 push 到远端仓库。另一位开发者在 B 的基础上，同样 commit 了一次并 push 到远端仓库。那么这个时候，我再 push 自己的代码就会发生错误，如下。To github.com:maoqyhz/usegit.git! [rejected] master -&gt; master (fetch first)error: failed to push some refs to ‘git@github.com:maoqyhz/usegit.git’hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., ‘git pull …’) before pushing again. 这个时候我们会选择，先 pull，再 push。Ok，push 成功，但是此时我们查看 log 就会发现除了我们自己提交的那条日志之外，会多出一条 “Merge branch ‘master’ of …”。在进行 pull 操作的同时，其实就是 fetch+merge 的一个过程。我们从 remote 分支中拉取新的更新，然后再合并到本地分支中去。 如果 remote 分支超前于本地分支，并且本地分支没有任何 commit 的，直接从 remote 进行 pull 操作，默认会采用 fast-forward 模式，这种模式下，并不会产生合并节点如果想之前那样，本地先 commit 后再去 pull，那么此时，remote 分支和本地会分支会出现分叉，这个时候使用 pull 操作拉取更新时，就会进行分支合并，产生合并节点和 log 信息。为了去除自动生成的 log 信息 可以git pull –rebase从 remote 分支拉取更新到本地时，使用 rebase。当完成 bug 修复或新功能时，使用 merge 将子分支合并到主分支。 跳转到的地方 reddit上面一个讨论 https://www.reddit.com/r/git/comments/j38kb1/what_does_it_mean_to_merge_master_into_feature/ 这是您的情况：您有一个commit一些内容的branch。同时，别人的更改更改已合并到 master。 下面内容二选一 将 master 合并到您的功能分支 或者 变基 然后再把功能分支合并到master (下图为第三步选择merge的效果) 上面的内容似乎并没有真正回答问题，于是我继续搜索，又看到了reddit上一篇帖子。感觉比上面的更贴近我想要的答案。https://www.reddit.com/r/git/comments/3qpvzk/question_why_would_you_merge_master_into_a_branch/ 本质上我们在讨论下面两种步骤的区别 12345678910111213141516在branch解决冲突git commit -m &#39;final feature commit&#39; # SHA: X1# git pull, git fetch&#x2F;mergegit merge mastergit commit -m &#39;resolve merge conflicts&#39; # SHA: Y1git checkout mastergit merge feature # SHA: M1 (merge commit)git branch -d feature在master解决冲突git commit -m &#39;final feature commit&#39; # SHA: X2git checkout master# git pull, git fetch&#x2F;mergegit merge feature # SHA: M2 (merge commit)git commit -m &#39;resolve merge conflicts&#39; # SHA: Y2git branch -d feature 文就在于你想在哪里解决冲突,在branch还是在master? 在master解决冲突，命令会更少。如果实在branch解决，会使得回滚更加方便。第一种只需要revert M1才能恢复之前的master。 第二种需要revert M2 and Y2. 尽管不是每个项目都需要第一种，还是建议养成这个习惯。 还有一点意义在于：长时间开发个人分支，时不时合并master into个人可以紧跟实事，减少最终大合并的工作量。","categories":[],"tags":[]},{"title":"b站尚硅谷springboot记录","slug":"b站尚硅谷springboot记录","date":"2021-06-29T06:46:58.000Z","updated":"2021-07-15T08:47:49.584Z","comments":true,"path":"2021/06/29/b站尚硅谷springboot记录/","link":"","permalink":"https://yiyayamaya.github.io/2021/06/29/b%E7%AB%99%E5%B0%9A%E7%A1%85%E8%B0%B7springboot%E8%AE%B0%E5%BD%95/","excerpt":"","text":"https://www.bilibili.com/video/BV19K4y1L7MT?p=43 前31p全看了 32~42源码没看 2021年07月12日15:33:45 从p45继续看 2021年07月15日10:05:51 p47跳过了 p48看了 49~51没看 63没看 646566看了 剩下的不想看了","categories":[],"tags":[]},{"title":"折腾tim微信企业微信折腾记录","slug":"折腾tim微信企业微信折腾记录","date":"2021-06-28T06:23:26.000Z","updated":"2021-11-30T05:34:17.163Z","comments":true,"path":"2021/06/28/折腾tim微信企业微信折腾记录/","link":"","permalink":"https://yiyayamaya.github.io/2021/06/28/%E6%8A%98%E8%85%BEtim%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/","excerpt":"","text":"微信安装这个wszqkzqk仓库下的版本，然后按照(https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/339) 更新到最新版，字体直接就没问题了。暂时使用流畅。 企业微信同样安装wszqkzqk仓库下的版本，然后去zq1997的源用apt wget安装3.16.3605,然后把后者覆盖前者,不覆盖版本过老不行，直接用后者体验不好也不行。暂时使用流畅。 tim用星火商店安装，安装后中文方框，把windows字体放到tim字体文件夹后方框解决但是不流畅+卡死，然后修改user.reg(https://bbs.deepin.org/zh/post/205436) 解决不流畅卡死问题。暂时使用流畅 env WINEPREFIX=~/.deepinwine/Deepin-TIM /home/wxj/.deepinwine/deepin-wine6-stable/bin/wine regedit 2021年09月11日11:21:58更新 tim不流畅 经常卡死 怀疑是tim跟搜狗输入法不咋兼容导致","categories":[],"tags":[]},{"title":"spring boot controller 接收参数的总结","slug":"spring-boot-controller-接收参数的总结","date":"2021-06-22T06:20:03.000Z","updated":"2021-12-10T05:49:41.079Z","comments":true,"path":"2021/06/22/spring-boot-controller-接收参数的总结/","link":"","permalink":"https://yiyayamaya.github.io/2021/06/22/spring-boot-controller-%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"contentType是告诉发送到服务端的数据类型，dataType是接收服务端的数据类型。 简单的数据用默认的application/x-www-form-urlencoded即可，post的方法体中会是a=bc&amp;d=e%2Cf形式。但是这种形式满足不了复杂的json嵌套。 上面的话展开说就是 这种格式的特点就是，name/value 成为一组，每组之间用 &amp; 联接，而 name与value 则是使用 = 连接。如： wwwh.baidu.com/q?key=fdsa&amp;lang=zh 这是get , 而 post 请求则是使用请求体，参数不在 url 中，在请求体中的参数表现形式也是: key=fdsa&amp;lang=zh的形式，这种形式在一般的情况下是没有什么问题的，但是在一些复杂的情况下就有问题了。 如果在ajax 中你要传一个复杂的json 对像，也&gt;就说是对象嵌数组，数组中包括对象，这样你怎么传： 1234567&#123; data: &#123; a: [&#123; x: 2 &#125;] &#125;&#125; 如上面这个复杂对象，get 和 post 都没有办法进行传送，因为历史的原因，ajax 只支持简单JSON对象(不带嵌套的)。所以在 ajax 中，你指定的 application/x-www-form-urlencoded 就不能传复杂JSON对象。你可以测试一下。application/json 的类型，把 json 的对像，用JSON.stringify序列化后，然后发送，在服务器端接到然后用 JSON.parse 进行还原就行了，这样就能处理复杂的对象了。 下面的内容可能不准确 因为本文重点在于application/x-www-form-urlencoded vs application/json。我之前不懂误以为是@RequestParam vs @RequestBody。 1.@RequestBody 注解，必须与 contentType 类型application/json配合使用。 把前端接收来的json封装到对象中。 https://blog.csdn.net/a460550542/article/details/103307204&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@RequestBody注解常用来处理POST请求，并且content-type不是默认的application/x-www-form-urlcoded编码的内容，比如说：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在《Spring 实战》中，表明了@RequestBody注解的含义和使用方式：用来解析请求体（可能是POST,PUT,DELETE,GET请求）中Content-Type为application/json类型的请求，利用消息转换器将其转换为对应的java对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当请求中的ContentType分别为一下三种类型时，结果如下： 是否加上注解\\ContentType x-www-form-urlencoded form-data application/json 不加@RequestBody注解 能接收 能接收 不能接收 加上@RequestBody注解 不能接收 不能接收 能接收 @RequestBody是读取的流的方式, 在取 body参数时第一个参数取到后把request.getInputStream()关闭，导致后面的@requestBody的对象拿取不到，就会报错。 @RequestBody，它是用来处理前台定义发来的数据Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等。 关于@RequestBody有一篇超长csdn文章https://blog.csdn.net/justry_deng/article/details/80972817 2.@RequestParam 注解，不加貌似也没区别， public String test(@RequestParam Long parentId) vs public String test( Long parentId)只是加了这个参数parentId就不能空了。除非用RequestParam(required=false)。 3.不加注解接收参数，参数类型可以为简单类型public String test(int parentId) ，也可以为对象类型 public String test(Version version)但是混用？ public String test(int parentId) public String test(Version version) public String test( Map&lt;String, Object&gt; map ) 啥也不加 + x-www-form-urlencoded 行 行 不行 @RequestParam + x-www-form-urlencoded 行 不行 不行 @RequestBody + application/json 不行 行 行 下面是一个ajax 规定了data类型JSON.stringify()； contentType是application/json 12345678910$.ajax(&#123; type: &quot;POST&quot;, data: JSON.stringify(task), contentType: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, url: &quot;&#x2F;updateTask&quot;,&#125;); 其对应的controller层就是这样的 完美对应上面的第三条。 1public Response updateTask(@RequestBody Task task) &#123;&#125; 如果想接受多个实体类 用map@RequestBody Map&lt;String, Version&gt; map也需要前台发来json但是map可不可以用@RequestParam呢 不行 application/x-www-form-urlencoded 这种形式是没有办法将复杂的 JSON 组织成键值对形式 https://www.cnblogs.com/htoooth/p/7242217.html controller里map接收了 怎么转呢？ 123456import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.TypeReference;JSON.parseObject(JSON.toJSONString(数据), new TypeReference&lt;对象&gt;() &#123;&#125;);","categories":[],"tags":[]},{"title":"spring mvc笔记","slug":"spring-mvc笔记","date":"2021-06-17T08:39:18.000Z","updated":"2021-06-29T01:59:48.955Z","comments":true,"path":"2021/06/17/spring-mvc笔记/","link":"","permalink":"https://yiyayamaya.github.io/2021/06/17/spring-mvc%E7%AC%94%E8%AE%B0/","excerpt":"","text":"5000 字的 Spring MVC 总结 - 动力节点在线的文章 - 知乎https://zhuanlan.zhihu.com/p/213805180 1.@Requestbody自动解析JSON字符串封装到对象 2.@ResponseBody这个注解会把对象自动转成json数据返回。不会再走视图。 2021-06-19 09:34:15更新 https://www.bilibili.com/video/BV1sk4y167pD?from=search&amp;seid=6134974228129061133 web开发底层是serverlet，springmvc中有一个dispatcherserverlet（中央调度器），负责接收用户的所有请求，用户把请求给了Dispatcherserverlet，Dispatcherserverlet把请求转发给Controller 在springboot中dispatcherserverlet被starterweb自动引入了。 关于组件扫描： @SpringBootApplication定义在MyApplication这个类上面，而这个类在包com.jdon.springboot下面。 @SpringBootApplication定义了对包com.jdon.springboot进行自动组件扫描。 如果所有组件都在上述包或其子包中定义，则一切正常。 关于ServletContext 首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境； 关于应用上下文 https://www.cnblogs.com/chenbenbuyi/p/8166304.html 什么是应用上下文呢，你可以简单的理解成就是将你需要Spring帮你管理的对象放入容器的那么一种。。一种。。额。。一种容器对象——是的，应用上下文即是Spring容器的一种抽象化表述；而我们常见的ApplicationContext本质上说就是一个维护Bean定义以及对象之间协作关系的高级接口。额，听起来是不是很抽象拗口？那你再读一遍呢。。。这里，我们必须明确，Spring的核心是容器，而容器并不唯一，框架本身就提供了很多个容器的实现，大概分为两种类型：一种是不常用的BeanFactory，这是最简单的容器，只能提供基本的DI功能；还有一种就是继承了BeanFactory后派生而来的应用上下文，其抽象接口也就是我们上面提到的的ApplicationContext，它能提供更多企业级的服务，例如解析配置文本信息等等，这也是应用上下文实例对象最常见的应用场景。有了上下文对象，我们就能向容器注册需要Spring管理的对象了。对于上下文抽象接口，Spring也为我们提供了多种类型的容器实现，供我们在不同的应用场景选择 有了以上理解，问题就很好办了。你只要将你需要IOC容器替你管理的对象基于xml也罢，java注解也好，总之你要将需要管理的对象（Spring中我们都称之问bean）、bean之间的协作关系配置好，然后利用应用上下文对象加载进我们的Spring容器，容器就能为你的程序提供你想要的对象管理服务了。","categories":[],"tags":[]},{"title":"记录一次hexo博客从windows被分到linux","slug":"记录一次hexo博客从windows被分到linux","date":"2021-05-18T12:45:49.000Z","updated":"2021-05-18T13:00:38.307Z","comments":true,"path":"2021/05/18/记录一次hexo博客从windows被分到linux/","link":"","permalink":"https://yiyayamaya.github.io/2021/05/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1hexo%E5%8D%9A%E5%AE%A2%E4%BB%8Ewindows%E8%A2%AB%E5%88%86%E5%88%B0linux/","excerpt":"","text":"遇到的坑就是明明没变的很多文件从windows换到linux上去，全被git追踪到了变化，可是我明明没改啊。最后没办法全gitignore了，最后只把source文件git备份上去了。本质就是用u盘来回拷souce文件夹嘛。。如果后面主题修改的话再用u盘拷吧。。。 操作流程是 想先发文的电脑 hexo d -g 然后看看git -am后push 另一台电脑想同步了就 git fetch –all #将git上所有文件拉取到本地git reset –hard origin/master #强制将本地内容指向刚刚同步git云端内容 至于为什么我也不太懂 此图用来测试的 无任何意义。","categories":[],"tags":[]},{"title":"一次笔试遇到的问题小总结","slug":"一次笔试遇到的问题小总结","date":"2021-04-29T11:26:01.000Z","updated":"2021-05-18T12:43:17.011Z","comments":true,"path":"2021/04/29/一次笔试遇到的问题小总结/","link":"","permalink":"https://yiyayamaya.github.io/2021/04/29/%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"123456789public static int test(int i) &#123; try &#123; i++; return i - 1; &#125; finally &#123; return i + 2; &#125; &#125; 上面的代码返回啥？答案是4.原因 try中有return, 会先将值暂存，无论finally语句中对该值做什么处理，最终返回的都是try语句中的暂存值。当try与finally语句中均有return语句，会忽略try中return。","categories":[],"tags":[]},{"title":"圣安地列斯裤子鞋子mod","slug":"圣安地列斯裤子鞋子mod","date":"2021-04-17T13:29:04.000Z","updated":"2021-05-18T12:43:17.015Z","comments":true,"path":"2021/04/17/圣安地列斯裤子鞋子mod/","link":"","permalink":"https://yiyayamaya.github.io/2021/04/17/%E5%9C%A3%E5%AE%89%E5%9C%B0%E5%88%97%E6%96%AF%E8%A3%A4%E5%AD%90%E9%9E%8B%E5%AD%90mod/","excerpt":"","text":"裤子txd贴图必须完全符合默认 128x256鞋子txd贴图只需要比例符合就可以 比如默认是64x64 那么512x512的也是可以的 有的人把裤子做的前移，和原版鞋子会穿模。但是这个人做的鞋子也会前移，这样只要你用他的裤子和他的搭配得鞋就不会出现问题。当然最好的作者是完全按照原版坐标来，随意搭配。","categories":[],"tags":[]},{"title":"leetcode57的两道题双指针对撞","slug":"leetcode57的两道题双指针对撞","date":"2021-04-16T14:44:52.000Z","updated":"2021-05-18T12:43:17.011Z","comments":true,"path":"2021/04/16/leetcode57的两道题双指针对撞/","link":"","permalink":"https://yiyayamaya.github.io/2021/04/16/leetcode57%E7%9A%84%E4%B8%A4%E9%81%93%E9%A2%98%E5%8F%8C%E6%8C%87%E9%92%88%E5%AF%B9%E6%92%9E/","excerpt":"","text":"剑指 Offer 57 - II. 和为s的连续正数序列剑指 Offer 57. 和为s的两个数字 感觉有点像 第二个是双指针对撞法 第一个也是双指针 但是不是撞了","categories":[],"tags":[]},{"title":"看到过的讲int范围最清晰的文章","slug":"看到过的讲int范围最清晰的文章","date":"2021-03-26T12:43:13.000Z","updated":"2021-05-18T12:43:17.015Z","comments":true,"path":"2021/03/26/看到过的讲int范围最清晰的文章/","link":"","permalink":"https://yiyayamaya.github.io/2021/03/26/%E7%9C%8B%E5%88%B0%E8%BF%87%E7%9A%84%E8%AE%B2int%E8%8C%83%E5%9B%B4%E6%9C%80%E6%B8%85%E6%99%B0%E7%9A%84%E6%96%87%E7%AB%A0/","excerpt":"","text":"https://blog.csdn.net/y12345678904/article/details/52854230","categories":[],"tags":[]},{"title":"cookie session token","slug":"cookie-session-token","date":"2021-03-25T09:08:50.000Z","updated":"2021-05-18T12:43:17.003Z","comments":true,"path":"2021/03/25/cookie-session-token/","link":"","permalink":"https://yiyayamaya.github.io/2021/03/25/cookie-session-token/","excerpt":"","text":"https://segmentfault.com/q/1010000010357830 1.上面这段话中，跨站伪造请求最开始窃取了目标网站的cookie发送了请求，那么如果我们将token放在了cookie中，不还是被窃取到了，到服务器的时候也是一样的拿到cookie中的token然后通过了认证么？ 你的应用用到了 cookie,那么后台验证就不能仅仅依赖 cookie,所以要额外加一个不通过 cookie 携带的验证参数，就是你题中说的 token 了。 至于这个 Token 怎么发送到前台就是另一个问题了： 提交表单时，token一般会作为表单的一个隐藏域被提交，类似，提交到服务器之后，服务器再校验表单提交的token和cookie中的token是否一致，一致则校验通过，不一致则很可能是CSRF攻击者的伪造请求。CSRF的确可以把Cookie提交到服务器，但是伪造不了表单的token，因为他拿不到Cookie的内容，那就通过不了校验。 又找了很多资料，准确来说，在很多场景中，token主要是为了用来实现跨域单点登录，单就实现这个功能来说，token放在cookie中或者post数据或者其他http请求头参数中都是可以的。但是，如果要防止CSRF，就不能将token放在cookie中。CSRF本质上是恶意页面利用了浏览器中正常页面的cookie，如果token存储在cookie中，点击恶意页面时，token就会在cookie中一起被提交到后端，后端对其验证是可以通过的。但如果存储在post数据或者其他http请求头参数中，在点击恶意页面时，由于正常页面post数据或者其他http请求头参数不会随着恶意页面而被提交到后端，恶意页面中也就没有token，后端就不会通过恶意页面的验证，再加上token的随机性，攻击者也无法在恶意页面中构造一个合法的token，从而防止CSRF。","categories":[],"tags":[]},{"title":"java面试题笔记","slug":"java面试题笔记","date":"2021-03-13T07:06:45.000Z","updated":"2021-07-26T02:00:07.507Z","comments":true,"path":"2021/03/13/java面试题笔记/","link":"","permalink":"https://yiyayamaya.github.io/2021/03/13/java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"https://www.bilibili.com/video/BV1Eb4y1R7zd p1.面向对象 多态 编译时运行时指向不一样。 多态无法调用子类成员函数。Person XiaoMing= new Man(); XiaoMing.只能跟Person有的方法,如果Man重写过就用Man的,不然就Person的。 要是想用Man的得加个(Man)XiaoMing。属性和方法不一样，访问得到的是Person的属性。 多态作用一个是方法参数一个是返回值。都可以编译时写成Person运行时用Man。 12345678public void test(A a)&#123; a.x()&#125;&#x2F;&#x2F; b是B的对象，这时候test方法中就调用了B的x方法test(b)&#x2F;&#x2F; c是C的对象，这时候test方法中就调用了C的x方法test(c) 另外,我我们在JDK中可以大量的看到多态的应用,比如在Object类中的equals(Object obj)方法中,参数是个Object类型的参数.因为Object是Java中所有类的基类.,但是才传入参数的时候,可以传入任何一个类的对象 p3.JDK JRE JVM Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码.class，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码， p4.== vs equals ==：基本数据类型(byte、short、int、long、float、double)比较变量值，引用类型比较对象地址。 equals默认也是==，但通常会重写。 p5.final p6.String、StringBuffer、StringBuilder区别及使用场景 p7.重载重写 重载：只有返回类型不同，没法区分方法，会报错。参数列表不同的基础上返回类型可以不同。 12345public int add(int a,int b)&#123; return 0;&#125;public String add(int a,int b)&#123; return &quot;sb&quot;;&#125; &#x2F;&#x2F;会报错public String add(String a,int b)&#123; return &quot;sb&quot;;&#125;&#x2F;&#x2F;没问题 重写：private方法不能重写。 p8.抽象类和接口 抽象类可以有普通成员函数，接口只能存在public abstract 方法。换句话说抽象类可以有实现，接口只有声明没有实现。抽象类继承一个，接口实现多个。 接口目的是规范，抽象类目的是复用。接口是has A，抽象类是is A。 以下内容介绍抽象类，摘抄自 https://www.liaoxuefeng.com/wiki/1252599548343744/1260456371027744 https://www.runoob.com/java/java-abstraction.html 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 从Person类派生的Student和Teacher都可以覆写run()方法。 如果父类Person的run()方法没有实际意义，能否去掉方法的执行语句？答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。 能不能去掉父类的run()方法？ 答案还是不行，因为去掉父类的run()方法，就失去了多态的特性。 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： 必须把Person类本身也声明为abstract，才能正确编译它： 123abstract class Person &#123; public abstract void run();&#125; 抽象类强迫子类实现其定义的抽象方法，否则编译会报错(除非子类也是抽象类)。因此，抽象方法实际上相当于定义了“规范”。 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象 p9.List和Set区别 List有序可重复，Set无序不可重复。 p10.hashcode和equals 视频讲的不好建议看这篇https://www.cnblogs.com/skywang12345/p/3324958.html p11.ArrayList和LinkedList 读取(也就是按位get)数组快 O(1) vs O(n) 查询一样 删除插入 若尾插可能也是数组快 头插可能是链表快。插入删除快指的可能是已找到待删除后删除操作本身。 原问题为：「本人新手，按照我的想法链表删除某个元素时，不是应该先找到该元素的位置么，求大佬解析一下」 当看到这句话「从链表或者数组中删除某个元素」时，大部分人的反应都会想到：先得找到待删除的元素，然后再删除。 而很多「教科书」中表达的意思是：假设已经找到了待删除的元素，只讨论删除操作本身，所需要的时间复杂度。 查找待删除的元素，无论单链表，还是数组(无序），复杂度都是O(n) 找到待删除的元素以后，进行删除操作时，链表可以将待删除的节点的前继节点next指针直接指向待删除元素的后续节点即可，时间复杂度是O(1）；而数组需要进行搬移操作，时间复杂度是O(n) 用时间复杂度表示的话，ArrayList的get（n）是o（1），而LinkedList是o（n）。 图里说链表不能用get意思是很慢 所以不能用。 p12.hashmap https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/ https://www.liaoxuefeng.com/wiki/1252599548343744/1265117217944672 我们再思考一下HashMap为什么能通过key直接计算出value存储的索引。相同的key对象（使用equals()判断时返回true）必须要计算出相同的索引，否则，相同的key每次取出的value就不一定对。 通过key计算索引的方式就是调用key对象的hashCode()方法，它返回一个int整数。HashMap正是通过这个方法直接定位key对应的value的索引，继而直接返回value。 由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入。因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布。 一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当n是2的幂次方时：hash &amp; (length - 1) == hash % length 在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。 因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了 p13.concurrentHashMap 没看 p14.IOC 没懂 p15.字节码 p16.java类加载器 没看懂 p17.双亲委派 基于16的。没懂，向上委派，向下查找。 p18. p19.GC如何判断对象可以被回收。 引用计数法。 可达性分析法。 p20.线程生命周期和状态 p21.讲的不好 关于线程状态建议看这篇文章 讲的超级好https://my.oschina.net/goldenshaw/blog/802620 主要是sleep和wait的关系 两种阻塞 是否释放锁。还得再看看。 p22.对线程安全的理解(主要讲了堆内存 栈内存) 堆是共享内存，可以被所有线程访问。存放对象实例和数组。 栈是线程独有的。是线程安全的。 在Java中，栈stack内存是用来存储函数的主体和变量名的。Java中的代码是在函数体中执行的，每个函数主体都会被放在栈内存中，比如main函数。加入main函数里调用了其他的函数，比如add（），那么在栈里面的的存储就是最底层是main，mian上面是add。栈的运行时后入先出的，所以会执行时会先销毁add，再销毁main。 在Java中，堆内存是用来存储实例的。比如main函数里面声明了一个people的类per，people per；这个per是存储在栈stack内存中的，实例化后（per = new people（））；实例后的对象实体是存在堆heap内存中的。栈stack内存中存储的per存储着指向堆heap内存的地址指向。堆heap内存的存在是为了更好的管理内存，实现garbage collection。当per不再指向堆heap内存中的实例的时候，garbage collection机制就会把这个堆heap内存中的new people（）实例删除，释放内存。 链接：https://www.zhihu.com/question/24807877/answer/139282174 p24.守护线程 没看完 开始跳着看了 p27.并发、并行、串行。 串行就是执行完任务1执行任务2。 并发执行任务1一半了执行任务2，2执行了一半又回到任务1。 并行两个任务一起执行。 p28并发三大特性 只看了第一个特性 还没看懂。 p29 p30线程池参数+处理流程 p34.AOP 讲的不好 看这两个知乎回答。 什么是面向切面编程AOP？ - 柳树的回答 - 知乎https://www.zhihu.com/question/24863332/answer/350410712 面向切面编程（AOP），那我们说的切面到底是什么？ - 葛尧的回答 - 知乎https://www.zhihu.com/question/57741911/answer/154139735 p35.IOC 讲的不好 看这个知乎回答。 Spring IoC有什么好处呢？ - Mingqi的回答 - 知乎https://www.zhihu.com/question/23277575/answer/169698662","categories":[],"tags":[]},{"title":"主站104=剑指 Offer 55 - I.二叉树的深度","slug":"主站104=剑指-Offer-55-I-二叉树的深度","date":"2021-03-12T09:07:39.000Z","updated":"2021-10-06T13:39:03.325Z","comments":true,"path":"2021/03/12/主站104=剑指-Offer-55-I-二叉树的深度/","link":"","permalink":"https://yiyayamaya.github.io/2021/03/12/%E4%B8%BB%E7%AB%99104=%E5%89%91%E6%8C%87-Offer-55-I-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"这棵树 普通的bfs 123456789 while(!queue.isEmpty()) &#123; root&#x3D;queue.poll(); depth++; if(root.left!&#x3D;null) queue.offer(root.left); if(root.right!&#x3D;null) queue.offer(root.right); &#125; 求深度用的bfs 123456789while (!queue.isEmpty()) &#123; res++; int n &#x3D; queue.size(); for (int i &#x3D; 0; i &lt; n; i++) &#123; TreeNode node &#x3D; queue.poll(); if (node.left !&#x3D; null) queue.add(node.left); if (node.right !&#x3D; null) queue.add(node.right); &#125; &#125; 对应的每次while时队列状态如下图。 可以看到上面的第2 3步会对应两个while导致深度加了两次，而下面的2 3步合到一个for里，相当于每次while对应一层。","categories":[],"tags":[]},{"title":"递归返回void/int类型的思考","slug":"递归返回void-int类型的思考","date":"2021-03-12T08:12:56.000Z","updated":"2021-05-18T12:43:17.015Z","comments":true,"path":"2021/03/12/递归返回void-int类型的思考/","link":"","permalink":"https://yiyayamaya.github.io/2021/03/12/%E9%80%92%E5%BD%92%E8%BF%94%E5%9B%9Evoid-int%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"剑指offer 54. 二叉搜索树的第k大节点 https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/ 123456789101112131415class Solution &#123; int res, k; public int kthLargest(TreeNode root, int k) &#123; this.k = k; dfs(root); return res; &#125; void dfs(TreeNode root) &#123; if(root == null) return; dfs(root.right); if(k == 0) return;//这句很巧妙 提前返回 if(--k == 0) res = root.val; dfs(root.left); &#125;&#125; 加了一句 if(k == 0) return; 起到了提前返回的作用，很神奇。 其中我自己想写的话就想为什么要设一个全局变量k呢？为什么不能返回root.val呢？ 就像下面这么写。 123456789101112131415static int dfs(TreeNode root) &#123; if(root == null) return 0; dfs(root.right); if(--k == 0) &#123; res = root.val; return root.val; &#125; dfs(root.left); return 0; &#125; 但是试了一下发现，返回root.val并不会结束最外面的dfs,最后还要return 0; 所以return的root.val只是跳出了一次dfs,根本无人记录下来啊。所以这里的return 0也好 return root.val也好都没意义了 和return 没区别。真正起作用的还是全局的res记录了root.val。","categories":[],"tags":[]},{"title":"二叉树相关问题目录","slug":"二叉树相关问题目录","date":"2021-03-11T08:04:52.000Z","updated":"2021-05-18T12:43:17.011Z","comments":true,"path":"2021/03/11/二叉树相关问题目录/","link":"","permalink":"https://yiyayamaya.github.io/2021/03/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9B%AE%E5%BD%95/","excerpt":"","text":"前中后序 非递归前序写法(即DFS) 中序三种非递归写法(说实话我都不熟悉) BFS用得很少，没有递归(可能有不常用 常用queue实现) lc257-二叉树的所有路径 递归 非递归DFS 非递归BFS","categories":[],"tags":[]},{"title":"通过lc160-相交链表学习双指针法","slug":"通过lc160-相交链表学习双指针法","date":"2021-03-08T13:22:34.000Z","updated":"2021-05-18T12:43:17.015Z","comments":true,"path":"2021/03/08/通过lc160-相交链表学习双指针法/","link":"","permalink":"https://yiyayamaya.github.io/2021/03/08/%E9%80%9A%E8%BF%87lc160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/","excerpt":"","text":"编写一个程序，找到两个单链表相交的起始节点。 我的办法是把A链表节点全断了，这样B的尽头就是相交的节点了。但是题目要求不改变原本链表。所以我的办法不行 双指针法 https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-fa-lang-man-xiang-yu-by-ml-zimingm/ 做法：我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点。 评论：太6了，我的理解： 两个链表长度分别为L1+C、L2+C， C为公共部分的长度，按照楼主的做法： 第一个人走了L1+C步后，回到第二个人起点走L2步；第2个人走了L2+C步后，回到第一个人起点走L1步。 当两个人走的步数都为L1+L2+C时就两个家伙就相爱了 之前有一道题也是用的类似方法，剑指offer22题，链表中倒数第k个节点。 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5. https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/ 做法：两个指针，前指针先走k步了后指针出发，前指针走到头，后指针停下。 -- 这类题给我感觉像小学桌子上站个小猫，地上站个大狗然后谁比谁高多少，让你求谁多高那种题。","categories":[],"tags":[]},{"title":"lc257-二叉树的所有路径","slug":"lc257-二叉树的所有路径","date":"2021-03-07T14:09:33.000Z","updated":"2021-05-18T12:43:17.011Z","comments":true,"path":"2021/03/07/lc257-二叉树的所有路径/","link":"","permalink":"https://yiyayamaya.github.io/2021/03/07/lc257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/","excerpt":"","text":"想了好久自己没想出来,是因为昨天没睡好吗？这也能简单？？和第113题path-sum-ii很像 官方回答两种办法 1.(递归) 这个递归，返回值为空，通过一直传递path就行了，反正我写不出来。 123456789101112131415161718192021class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; paths = new ArrayList&lt;String&gt;(); constructPaths(root, \"\", paths); return paths; &#125; public void constructPaths(TreeNode root, String path, List&lt;String&gt; paths) &#123; if (root != null) &#123; StringBuffer pathSB = new StringBuffer(path); pathSB.append(Integer.toString(root.val)); if (root.left == null &amp;&amp; root.right == null) &#123; // 当前节点是叶子节点 paths.add(pathSB.toString()); // 把路径加入到答案中 &#125; else &#123; pathSB.append(\"-&gt;\"); // 当前节点不是叶子节点，继续递归遍历 constructPaths(root.left, pathSB.toString(), paths); constructPaths(root.right, pathSB.toString(), paths); &#125; &#125; &#125;&#125; 2.DFS(迭代)维护两个stack，进出操作一摸一样。反正很巧妙，说不清。。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; if(root == NULL) return res; stack&lt;TreeNode*&gt; stack1; // 存放遍历的结点 stack&lt;string&gt; stack2; // 存放从根节点到遍历结点的路径 stack1.push(root); stack2.push(to_string(root-&gt;val)+ \"\"); while(!stack1.empty())&#123; // 结点和该结点的路径同时出栈 TreeNode* node = stack1.top(); stack1.pop(); string path = stack2.top(); stack2.pop(); if(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) &#123; res.push_back(path); &#125; else &#123; if(node-&gt;left) &#123; stack1.push(node-&gt;left); stack2.push(path + \"-&gt;\" + to_string(node-&gt;left-&gt;val)); &#125; if(node-&gt;right) &#123; stack1.push(node-&gt;right); stack2.push(path + \"-&gt;\" + to_string(node-&gt;right-&gt;val)); &#125; &#125; &#125; return res; &#125;&#125;; 3.BFS(迭代)维护两个队列，进出操作一摸一样。反正很巧妙，说不清。。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; paths = new ArrayList&lt;String&gt;(); if (root == null) &#123; return paths; &#125; Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;TreeNode&gt;(); Queue&lt;String&gt; pathQueue = new LinkedList&lt;String&gt;(); nodeQueue.offer(root); pathQueue.offer(Integer.toString(root.val)); while (!nodeQueue.isEmpty()) &#123; TreeNode node = nodeQueue.poll(); String path = pathQueue.poll(); if (node.left == null &amp;&amp; node.right == null) &#123; paths.add(path); &#125; else &#123; if (node.left != null) &#123; nodeQueue.offer(node.left); pathQueue.offer(new StringBuffer(path).append(\"-&gt;\").append(node.left.val).toString()); &#125; if (node.right != null) &#123; nodeQueue.offer(node.right); pathQueue.offer(new StringBuffer(path).append(\"-&gt;\").append(node.right.val).toString()); &#125; &#125; &#125; return paths; &#125;&#125;","categories":[],"tags":[]},{"title":"前中后序","slug":"前中后序","date":"2021-03-06T07:05:18.000Z","updated":"2021-05-18T12:43:17.011Z","comments":true,"path":"2021/03/06/前中后序/","link":"","permalink":"https://yiyayamaya.github.io/2021/03/06/%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F/","excerpt":"","text":"本篇讨论都是迭代写法 二叉树的前序=二叉树的dfs 比较符合人的思路 123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; st&#x3D;new Stack&lt;TreeNode&gt;(); List&lt;Integer&gt; result&#x3D;new ArrayList&lt;Integer&gt;(); if(root&#x3D;&#x3D;null) return result; st.push(root); while(!st.empty())&#123; TreeNode cur&#x3D;st.pop(); result.add(cur.val); if(cur.right!&#x3D;null) st.push(cur.right); if(cur.left!&#x3D;null) st.push(cur.left); &#125; return result; &#125;&#125; 中序按照符合人的思路来比较不优雅，解题思路https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/jin-hu-shuang-bai-de-die-dai-zhong-xu-by-h4ri/ 1.对于当前中序遍历到的某个节点，如果他左子树不空，就往左遍历， 2.当作子树为空或遍历返回到当前节点时，访问当前这个节点（操作一下），然后将当前节点的左指针制空（防止循环遍历卡住） 3.判断当前节点的右子树是否为空，不空就向右遍历，回到1，空就向上返回。 大概思路就是 如果如果左边有孩子，第一次会在if里加进去，第二次就会跳过这if了。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; &#x2F;&#x2F; 使用迭代 直接压栈即可 List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;(); Stack &lt;TreeNode&gt; stack&#x3D;new Stack&lt;TreeNode&gt;(); stack.push(root); if(root &#x3D;&#x3D; null) &#x2F;&#x2F;处理特殊情况 return res; while(!stack.empty()) &#123; if(root.left !&#x3D; null) &#x2F;&#x2F;如果当前节点的左子树不空，就向左走，压栈左儿子节点 &#123; stack.push(root.left); root &#x3D; root.left; &#125; else &#x2F;&#x2F;如果当前节点的左子树空了 &#123; root &#x3D; stack.pop(); &#x2F;&#x2F;弹栈，返回上一个遍历到的节点 res.add(root.val); &#x2F;&#x2F;把他压入返回数组，此时就是中序的顺序 root. left &#x3D; null; &#x2F;&#x2F;将左指针制空，表明当前节点的左边已经处理过了 if(root.right !&#x3D; null) &#x2F;&#x2F;判断当前节点的右子树空不空，不空就进入右遍处理 &#123; root &#x3D; root.right; stack.push(root); &#125; &#125; &#125; return res; &#125;&#125; 还有一个写法 也比标准答案舒服一点。https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/shou-hua-tu-jie-yong-zhan-mo-ni-zhong-xu-bian-li-z/ 12345678910111213141516171819const inorderTraversal &#x3D; (root) &#x3D;&gt; &#123; const res &#x3D; []; const stack &#x3D; []; while (root) &#123; &#x2F;&#x2F; 能压入栈的左子节点都压进来 stack.push(root); root &#x3D; root.left; &#125; while (stack.length) &#123; let node &#x3D; stack.pop(); &#x2F;&#x2F; 栈顶的节点出栈 res.push(node.val); &#x2F;&#x2F; 在压入右子树之前，处理它的数值部分（因为中序遍历） node &#x3D; node.right; &#x2F;&#x2F; 获取它的右子树 while (node) &#123; &#x2F;&#x2F; 右子树存在，执行while循环 stack.push(node); &#x2F;&#x2F; 压入当前root node &#x3D; node.left; &#x2F;&#x2F; 不断压入左子节点 &#125; &#125; return res;&#125;; 不按照人的思路来写 个人感觉这个看能看懂 自己写很容易忘 没什么意思 但是这种写法可以推广到前序和后序 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if (root &#x3D;&#x3D; null) &#123; return Collections.emptyList(); &#125; Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;TreeNode&gt;(); List&lt;Integer&gt; res &#x3D; new LinkedList&lt;&gt;(); while (root !&#x3D; null || !stack.isEmpty()) &#123; if (root !&#x3D; null) &#123; stack.push(root); root &#x3D; root.left; &#125; else &#123; TreeNode node &#x3D; stack.pop(); res.add(node.val); if (node.right !&#x3D; null) &#123; root &#x3D; node.right; &#125; &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"java8,使用Lambda表达式和foreach","slug":"java8-使用Lambda表达式和foreach","date":"2021-01-17T10:28:41.000Z","updated":"2021-07-06T01:03:43.111Z","comments":true,"path":"2021/01/17/java8-使用Lambda表达式和foreach/","link":"","permalink":"https://yiyayamaya.github.io/2021/01/17/java8-%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cforeach/","excerpt":"","text":"先开个坑！！！","categories":[],"tags":[]},{"title":"记录一个maven镜像配置","slug":"记录一个maven镜像配置","date":"2021-01-16T15:57:33.000Z","updated":"2021-05-18T12:43:17.015Z","comments":true,"path":"2021/01/16/记录一个maven镜像配置/","link":"","permalink":"https://yiyayamaya.github.io/2021/01/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAmaven%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/","excerpt":"","text":"maven匹配镜像的原理这篇讲的很好，贴了源码。https://www.cnblogs.com/ctxsdhy/p/8482725.html以后我就按下面这么配了，先去阿里云找，找不到的去官方找。 1234567891011121314&lt;mirrors&gt;&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;&#x2F;id&gt; &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt; &lt;name&gt;aliyun maven&lt;&#x2F;name&gt; &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; &lt;mirror&gt; &lt;id&gt;central-repository&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;name&gt;Other Mirror Repository&lt;&#x2F;name&gt; &lt;url&gt;https:&#x2F;&#x2F;repo.maven.apache.org&#x2F;maven2&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt;&lt;&#x2F;mirrors&gt;","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://yiyayamaya.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"hexo+github博客引入indigo主题的几个坑+评论","slug":"hexo-github博客引入indigo主题的几个坑+评论","date":"2021-01-13T16:05:27.000Z","updated":"2021-07-02T02:55:24.352Z","comments":true,"path":"2021/01/13/hexo-github博客引入indigo主题的几个坑+评论/","link":"","permalink":"https://yiyayamaya.github.io/2021/01/13/hexo-github%E5%8D%9A%E5%AE%A2%E5%BC%95%E5%85%A5indigo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91+%E8%AF%84%E8%AE%BA/","excerpt":"","text":"众所周知，indigo是最好的主题。而且我就知道这一个，所以就用这个了。但是这个好久不更新了，新版本hexo用有坑。报错如下 1Unhandled rejection ReferenceError: F:\\blog\\themes\\indigo\\layout\\layout.ejs:6 其实报错特别长，但我现在找不到了。。https://github.com/yscoder/hexo-theme-indigo/issues/522#issuecomment-717879358这里的方法完美的解决问题。还有说最好用hexo3+版本的，毕竟indigo是为3+准备的。我的hexo版本是5.3 2021.07.02更新 上述方法并不能完美解决问题。比如加入”### “标题就会报错。https://github.com/yscoder/hexo-theme-indigo/issues/522#issuecomment-872667641后面还是换回了hexo4版本 上面的问题就解决了，之前的修改也撤销了。但是会报这个错ERROR Plugin load failed: hexo-theme-landscape我直接在package.json里把这行去掉了，不知道会不会有什么隐患。。。 第二个坑：换了主题后hexo d的文件太大了，总失败。解决办法：去美国提交。办法二：把_config.yml里面根据自己账号改成这样就好了。原因不详。 第二个坑的参考链接：https://github.com/hexojs/hexo/issues/3043#issuecomment-415035343 然后我用了想加评论功能，发现indigo集成了几个评论插件，其中有gitment和gitalk。前者我试了配置一下没成功，据说也不怎么维护了。于是决定用gitalk。 这个插件是一个叫@ystyle的人merge进去的。https://github.com/yscoder/hexo-theme-indigo/pull/456他设定的配置格式在themes/indigo/_config.yml里面，长这样。 12345gitalk: false owner: repo: client_id: client_secret: 但是果然失败了。因为他的配置格式不对。 有一个叫@zzycreate的人写了一篇博客讲indigo集成gitalk。https://zzycreate.github.io/2018/10/03/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/他俩的实现方式是一摸一样的，太神奇了。重点是第二个人的配置格式是对的。 gitalk: enable: true client_id: client_secret: repo: yiyayamaya.github.io owner: yiyayamaya admin: admins distractionFreeMode: false #注意上面每行中间一定要有空格 总结一下就是用官方indigo里面的集成的gitalk.ejs就足够了，但是要把配置格式按照博客里面那么写，而不是官方自带格式。","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://yiyayamaya.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"IDEA中Mave Module的Language Level问题","slug":"IDEA中Mave-Module的Language-Level问题","date":"2021-01-13T11:59:48.000Z","updated":"2021-05-18T12:43:17.003Z","comments":true,"path":"2021/01/13/IDEA中Mave-Module的Language-Level问题/","link":"","permalink":"https://yiyayamaya.github.io/2021/01/13/IDEA%E4%B8%ADMave-Module%E7%9A%84Language-Level%E9%97%AE%E9%A2%98/","excerpt":"","text":"idea maven工程的module的Language Level总是自动变到5, 每次reload项目都要手动改。 可能是某个module的包默认用5编译(参考里这么说的)。上网一搜发现很多人遇到过这个问题。在pom.xml中加入下面这个，好了。 1234&lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;&lt;&#x2F;properties&gt; 参考:https://www.cnblogs.com/larryzeal/p/5552360.html","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://yiyayamaya.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"二分查找总结","slug":"二分查找总结","date":"2021-01-10T08:05:04.000Z","updated":"2021-05-18T12:43:17.011Z","comments":true,"path":"2021/01/10/二分查找总结/","link":"","permalink":"https://yiyayamaya.github.io/2021/01/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/","excerpt":"","text":"看到一个总结网址，还没来得及看完。https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/ 牛客剑指offer中一道题，二维数组中的查找leetcode第35题Search Insert Position 文章的总结两个思路思路1 while(left &lt;= right)思路2 while(left &lt; right) 是排除，在left=right时终止，最后剩下一个元素，可能就是答案。「左右边界向中间走，两边夹」本文主要讨论思路2 1234while (left &lt; right) &#123; 用本轮区间即leftright值算mid; 比较mid和target确定下轮区间即leftright值；&#125; 举例如下 最普通二分-找到一个等于target的值就行 12345678910111213while (left &lt; right) &#123; int mid = left + (right - left) / 2; // 严格小于 target 的元素一定不是解 if (nums[mid] &lt; target) &#123; // 下一轮搜索区间是 [mid + 1, right] left = mid + 1; &#125; else &#123; // 下一轮搜索区间是 [left, mid] right = mid; &#125;&#125;可能找到最后也没找到，后面可能要加补丁。下面有详细介绍。 因为35题可以理解为找到大于等于 target 的第 11 个元素的位置，所以严格小于 target 的元素一定不是解。上面是把 (left,mid) 排除出去了所以剩下的区间就是 (mid+1,right) . 关于取中位数基于此题解，有个记忆的口诀是「左动取左，右动取右」，即 if (…) left = mid + 1; 归为「左动」，对应左中位数；if (…) right = mid - 1; 归为「右动」，对应右中位数。 详见这个里面https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/评论区里lzhlyle的回答。 1234567891011//找到第一个出现的targetwhile(left&lt;right) &#123; mid=left+(right-left)/2;//左中点 if(nums[mid]&lt;target) left=mid+1; else if(nums[mid]&gt;target) right=mid-1;//此处两个right可以合并成right=mid 但我觉得不好理解 没有合并 else right=mid; &#125; 1234567891011// 查找最后一个值等于给定值的元素 while(left&lt;right)//找到最后一个出现的target 此时必须上取整 右中点 &#123; mid=left+((right-left+1)&gt;&gt;1);//上取整 右中点 if(nums[mid]&lt;target) left=mid+1;//此处两个left可以合并 else if(nums[mid]&gt;target) right=mid-1; else left=mid;//此处不一样 &#125; 以下把等于改成大等或小等 只需要改补丁的if就行了 1234567891011&#x2F;&#x2F; 查找第一个大于等于给定值的元素private int firstLargeOrEquals(int[] arr, int target) &#123; int l &#x3D; 0, r &#x3D; arr.length - 1; while (l &lt; r) &#123; int mid &#x3D; l + ((r - l) &gt;&gt; 1); if (arr[mid] &lt; target) l &#x3D; mid + 1; else r &#x3D; mid; &#x2F;&#x2F; 收缩右边界不影响 first equals &#125; if (arr[l] &gt;&#x3D; target &amp;&amp; (l &#x3D;&#x3D; 0 || arr[l - 1] &lt; target)) return l; &#x2F;&#x2F; &gt;&#x3D; return -1;&#125; 123456789101112&#x2F;&#x2F; 查找最后一个小于等于给定值的元素private int lastLessOrEquals(int[] arr, int target) &#123; int l &#x3D; 0, r &#x3D; arr.length - 1; while (l &lt; r) &#123; int mid &#x3D; l + ((r - l + 1) &gt;&gt; 1); if (arr[mid] &gt; target) r &#x3D; mid - 1; else l &#x3D; mid; &#x2F;&#x2F; 收缩左边界不影响 last equals &#125; if (arr[l] &lt;&#x3D; target &amp;&amp; (l &#x3D;&#x3D; arr.length - 1 || arr[l + 1] &gt; target)) return l; &#x2F;&#x2F; &lt;&#x3D; return -1;&#125; --- 对于704题最普通的二分查找来说标准答案给的是 1234567while(left &lt;&#x3D; right) &#123; ··· left &#x3D; mid + 1; ··· right &#x3D; mid - 1; ···&#125; 搜索区间为空的时候应该终止。 如果硬要用while(left &lt; right) 也可以但在结束后得加上一个补丁。循环只剩一个数时候会终止，此时left=right。得判断一下他是不是target。 123456789while(left &lt;&#x3D; right) &#123; ··· left &#x3D; mid + 1; ··· right &#x3D; mid - 1; ···&#125;if (nums[left]&#x3D;&#x3D;target) return left; https://leetcode-cn.com/problems/find-in-mountain-array/ 山脉这道题里判断mid处单调性为什么要mid和mid+1比；而不用mid和mid-1比？可能是因为前者需要 12left&#x3D;mid+1;right&#x3D;mid; 而后者要 12left&#x3D;mid;right&#x3D;mid-1; 我不确定这里说的对不对，但是前面提到过左中点要左动，也就是前者。后者会死循环。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yiyayamaya.github.io/tags/leetcode/"}]},{"title":"学习规划","slug":"学习规划","date":"2021-01-08T06:19:54.000Z","updated":"2021-05-18T12:43:17.015Z","comments":true,"path":"2021/01/08/学习规划/","link":"","permalink":"https://yiyayamaya.github.io/2021/01/08/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/","excerpt":"","text":"现在有的材料剑指offer题库计网操作系统面向对象网课github一个大厂面试常问问题。https://github.com/resumejob/interview-questions 还有一个java大全，这个好像有点太多了。https://github.com/xingshaocheng/architect-awesome 不知道怎么分配时间啊。","categories":[],"tags":[{"name":"找工","slug":"找工","permalink":"https://yiyayamaya.github.io/tags/%E6%89%BE%E5%B7%A5/"}]},{"title":"记录一下2021年1月5号飞机上看的APAS前十道题-有图了","slug":"记录一下2021年1月5号飞机上看的APAS前十道题-有图了","date":"2021-01-06T13:30:55.000Z","updated":"2021-05-18T12:43:17.015Z","comments":true,"path":"2021/01/06/记录一下2021年1月5号飞机上看的APAS前十道题-有图了/","link":"","permalink":"https://yiyayamaya.github.io/2021/01/06/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B2021%E5%B9%B41%E6%9C%885%E5%8F%B7%E9%A3%9E%E6%9C%BA%E4%B8%8A%E7%9C%8B%E7%9A%84APAS%E5%89%8D%E5%8D%81%E9%81%93%E9%A2%98-%E6%9C%89%E5%9B%BE%E4%BA%86/","excerpt":"","text":"这MD我也不会用啊 先凑合写写吧我发现APAS就是leetcode的顺序啊 这也太神奇了 哈哈 1.two sum在一个数组里找俩数，和是target要我自己做的话肯定是固定左标，然后右标跳，右标跳完左标跳。就是i (0,n)，然后j(i,n)。这个复杂度是n方，我还想了一下为啥是n方，想完发现还真是，也不知道算的对不对。然后他给的答案是用map,复杂度是n。为啥一个for里面加一个map.contaisKey是n？难道containsKey是复杂度1吗？查了一下有人讲解containsKey源码，太长懒得看了。还有什么正常复杂度是1最坏复杂度是nlogn，不能用最坏的算。2.Add Two Sum两个整数相加求和，要考虑进位啥的。这题练练链表怎么遍历，怎么一个节点一个节点的生成一个链表。我真正写的时候遇到了问题。。。(1)结果链表的头怎么保留，如果一直移动指向，头不就找不到了吗(2)我的结果链表续节点时候，如果两个加数已经遍历完了，那就不应该续新节点了。但是我会多续一个导致结果多一个0。问题1我看标准答案也没解决，直接把头和参与移动的指针分开了，到时候直接返回头.next。问题二就是先续节点，加数还有才续，不要加完了才续。 123ListNode nextNode&#x3D;new ListNode();currentNode.next&#x3D;nextNode;currentNode&#x3D;currentNode.next; 这个currentNode，只有.next时候他才能代表一个节点，不然只能看作一个指针。还挺巧妙。这题我想了很久很久啊，其实挺多细节的。比如 1234567&lt;!-- 保证有值才读 --&gt;int l1val&#x3D;0;int l2val&#x3D;0;if(l1!&#x3D;null) l1val&#x3D;l1.val;if(l2!&#x3D;null) l2val&#x3D;l2.val; 123456 while(l1!&#x3D;null||l2!&#x3D;null)&#123; &#x2F;&#x2F;把两个加数都走完了 &#125;if(carry&gt;0) currentNode.next&#x3D;new ListNode(carry); &#x2F;&#x2F;但是结果比长的加数还多一位 12345&lt;!-- while里面，每次都是给next节点赋值，也就是说第一次进来的currentNode根本没被用到，直接就是0了。 所以最后要return 头.next--&gt;ListNode nextNode&#x3D;new ListNode();currentNode.next&#x3D;nextNode;currentNode&#x3D;currentNode.next;currentNode.val&#x3D;(l1val+l2val+carry)%10; 3.Longest Substring Without Repeating Characters最长不重复子串，就是左标右标，右标遇到重复的了，就把左标挪到上一次遇到右标字母的位置的下一个。 12for(int i&#x3D;leftIndex;i&lt;leftIndexNew;i++) map.remove(s.charAt(i)); 我是上面这么写的。比如abcdcb当左=2右=4时，左会被更新为3。可是3以前的字母为什么不应该从map中删除呢，比如右接着滑到5发现map里面有(b,1)了，可是此时当前子串是dc里明明没有b啊。 12if (map.containsKey(s.charAt(j))) &#123; i &#x3D; Math.max(map.get(s.charAt(j)), i); 答案Sliding Window Optimized是这么写的,max()里比较的两个数，有下面两种情况，都可以用这一句话，挺神奇。 4.Median of Two Sorted Arrays我就把两个数组合成一个数组了。 两个有序数组的合并也是归并排序中的一部分 顺便奇偶个数数组求中值的问题我每次遇到都要想好久。。。我还写得什么长度-1后除以2再-0.2和+0.2之后四舍五入。。。下次我要按照下面这么写 12345if (count % 2 &#x3D;&#x3D; 0) &#123; return (nums[count &#x2F; 2 - 1] + nums[count &#x2F; 2]) &#x2F; 2.0; &#125; else &#123; return nums[count &#x2F; 2]; &#125; 改一下，其实是照着答案改的，好看了不少。 12345if(i2&#x3D;&#x3D;nums2.length)&#123; for(int j&#x3D;0;j&lt;total-i-1;j++) numsAdded[i+1+j]&#x3D;nums1[i1+j]; break;&#125; 改成 1234while(i1!&#x3D;nums1.length)&#123; numsAdded[(i++)+1]&#x3D;nums1[i1++];&#125; 答案给的是二分。。。懒得看了。。。 5.Longest Palindromic Substring这个没啥说的，写一个函数传入(string,左,右)判断是不是对称的。如果传入(string,i,i)就是围绕一个字母对称,传入(string,i,i+1)就是围绕两个字母对称。先判断当前对不对称，对称了再移动，所以围绕两个的字母会先验证。6.ZigZag Conversion我没有写，就大概想了一下。。。7.Reverse Integer要点就是怎么用while取反，真挺巧妙，让我不看答案我肯定写不出来。 12345while(left!&#x3D;0)&#123; unit&#x3D;left%10;&#x2F;&#x2F;个位 left&#x3D;left&#x2F;10;&#x2F;&#x2F;剩下的 result&#x3D;result*10+unit;&#125; 其实也不一定，我5号看的，今天8号。居然能写出来，哈哈。然后记得为了防止越界result要声明为long。 8.String to Integer (atoi)没写感觉没什么意思。 9.Palindrome Number也没写，我感觉这题和第七题一样。 10.Regular Expression Matching一道hard题，没什么思路。这个得以后认真做一下。 后记第六题和第十题都没写，第一次写日志有点虎肉蛇尾啊，哈哈。完成时间是上午2:252021年1月8日（星期五）","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yiyayamaya.github.io/tags/leetcode/"}]},{"title":"第一篇文章","slug":"第一篇文章","date":"2021-01-06T13:13:13.000Z","updated":"2021-05-18T12:43:17.015Z","comments":true,"path":"2021/01/06/第一篇文章/","link":"","permalink":"https://yiyayamaya.github.io/2021/01/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"2021/01/06 开始写博客 [toc] Heading some boldHeading 1.1 _some italicHeading 1.2 _some italicHeading 1.3 _some italicHeading 1.4 _some italicHeading 1.5 _some italic","categories":[],"tags":[{"name":"灌水","slug":"灌水","permalink":"https://yiyayamaya.github.io/tags/%E7%81%8C%E6%B0%B4/"}]}],"categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://yiyayamaya.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"leetcode","slug":"leetcode","permalink":"https://yiyayamaya.github.io/tags/leetcode/"},{"name":"找工","slug":"找工","permalink":"https://yiyayamaya.github.io/tags/%E6%89%BE%E5%B7%A5/"},{"name":"灌水","slug":"灌水","permalink":"https://yiyayamaya.github.io/tags/%E7%81%8C%E6%B0%B4/"}]}