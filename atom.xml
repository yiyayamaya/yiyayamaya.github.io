<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>皇姑区第一亚索的博客</title>
  
  
  <link href="https://yiyayamaya.github.io/atom.xml" rel="self"/>
  
  <link href="https://yiyayamaya.github.io/"/>
  <updated>2021-10-28T09:24:55.212Z</updated>
  <id>https://yiyayamaya.github.io/</id>
  
  <author>
    <name>皇姑区第一亚索</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springBoot 自动配置遇到的问题</title>
    <link href="https://yiyayamaya.github.io/2021/10/28/springBoot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://yiyayamaya.github.io/2021/10/28/springBoot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-28T09:20:30.000Z</published>
    <updated>2021-10-28T09:24:55.212Z</updated>
    
    <content type="html"><![CDATA[<p>1.配置数据源问题 application.yml可不可以什么都不写？<br>不配置数据源可能会报错 可能需要 @SpringBootApplication(exclude ={ DataSourceAutoConfiguration.class})<br>但是有时候不exclude也不报错？ 不懂为什么</p><p>2.用到shardingsphere时候，仅仅在maven中引用，没在任何地方调用就会报错(缺少shardingsphere的数据源配置)。<br>第一次遇见 是因为自动配置吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shardingsphere&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.配置数据源问题 application.yml可不可以什么都不写？&lt;br&gt;不配置数据源可能会报错 可能需要 @SpringBootApplication(exclude ={ DataSourceAutoConfiguration.class})&lt;br&gt;但是有时候不ex</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hehehehhe</title>
    <link href="https://yiyayamaya.github.io/2021/10/26/hehehehhe/"/>
    <id>https://yiyayamaya.github.io/2021/10/26/hehehehhe/</id>
    <published>2021-10-26T06:41:29.000Z</published>
    <updated>2021-10-26T06:42:11.915Z</updated>
    
    <content type="html"><![CDATA[<img src="/2021/10/26/hehehehhe/QQ%E6%88%AA%E5%9B%BE20210108015942.jpg" class="" title="This is an example image">]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2021/10/26/hehehehhe/QQ%E6%88%AA%E5%9B%BE20210108015942.jpg&quot; class=&quot;&quot; title=&quot;This is an example image&quot;&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql 分组结果的最大值记录</title>
    <link href="https://yiyayamaya.github.io/2021/10/25/mysql-%E5%88%86%E7%BB%84%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E8%AE%B0%E5%BD%95/"/>
    <id>https://yiyayamaya.github.io/2021/10/25/mysql-%E5%88%86%E7%BB%84%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E8%AE%B0%E5%BD%95/</id>
    <published>2021-10-25T12:39:38.000Z</published>
    <updated>2021-10-26T07:40:11.066Z</updated>
    
    <content type="html"><![CDATA[<p>一个常见问题 这类问题有一个名字  greatest-n-per-group 可以在stackOverFlow上看到大量讨论</p><p>分组中某栏最大好取 只要</p><p>SELECT id, MAX(rev)<br>FROM YourTable<br>GROUP BY id</p><p>若是要完整记录呢？<br>有两种方法 一种inner join 一种left join inner似乎快一点？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--标准答案之inner join 超级快</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs t1 </span><br><span class="line">                                     <span class="keyword">join</span>           (<span class="keyword">select</span> <span class="keyword">max</span>(heartbeat) a, machine_id b <span class="keyword">from</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs <span class="keyword">group</span> <span class="keyword">by</span> b)</span><br><span class="line">                                                    t <span class="keyword">on</span> t1.heartbeat=t.a <span class="keyword">and</span> t1.machine_id=t.b</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> machine_id</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--标准答案之inner join的另一种写法 和innerjoin语义上是等价 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs t1,</span><br><span class="line">                                                (<span class="keyword">select</span> <span class="keyword">max</span>(heartbeat) a, machine_id b <span class="keyword">from</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs <span class="keyword">group</span> <span class="keyword">by</span> b)</span><br><span class="line">                                                    t <span class="keyword">where</span> t1.heartbeat=t.a <span class="keyword">and</span> t1.machine_id=t.b</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> machine_id</span><br></pre></td></tr></table></figure><blockquote><p>插播1  </p><blockquote><p>为什么等价？<br>请教inner join 与一般笛卡尔积的区别，如select * from tb1 a inner join tb2 b on a.id=b.id 与select * from tb1 a ,tb2 b where a.id=b.id 有什么不同？谢谢！<br>答案：等价</p></blockquote><blockquote><p>笛卡尔积是怎么回事？{a,b},{0,1,2}-&gt;{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}</p></blockquote><blockquote><p>mysql笛卡尔积是什么写法？<br>笛卡尔积指的是交叉连接，交叉连接的语法格式如下：<br>SELECT &lt;字段名&gt; FROM &lt;表1&gt; CROSS JOIN &lt;表2&gt;<br>或<br>SELECT &lt;字段名&gt; FROM &lt;表1&gt;, &lt;表2&gt;<br>两者等价</p></blockquote><blockquote><p>为什么笛卡尔积不合理？ </p><img src="/2021/10/25/mysql-%E5%88%86%E7%BB%84%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E8%AE%B0%E5%BD%95/2021-10-26_11-54.png" class="" title="This is an example image"></blockquote><blockquote><p>为了避免这种情况的发生，可以采用等值连接的方法</p><img src="/2021/10/25/mysql-%E5%88%86%E7%BB%84%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E8%AE%B0%E5%BD%95/2021-10-26_11-55.png" class="" title="This is an example image"></blockquote><blockquote><p>带等值连接的笛卡尔积结果=内联</p></blockquote></blockquote><blockquote><p>插播2<br>我这个场景其实只需要 因为id是唯一的 且id大日期一定大 巧妙做法 但是如果需要的最大项不唯一且跟id没规律就不能这么用了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs <span class="keyword">GROUP</span> <span class="keyword">BY</span> machine_id)</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--标准答案之left join 不咋快</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> a.*</span><br><span class="line"><span class="keyword">FROM</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs a</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs b</span><br><span class="line">    <span class="keyword">ON</span> a.machine_id = b.machine_id <span class="keyword">AND</span> a.heartbeat &lt; b.heartbeat</span><br><span class="line"><span class="keyword">WHERE</span> b.machine_id <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为什么left join这么写是对的？How it works:</span></span><br><span class="line"><span class="comment">-- It matches each row from o with all the rows from b having the same value in column Group and a bigger value in column Age. Any row from o not having the maximum value of its group in column Age will match one or more rows from b.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- The LEFT JOIN makes it match the oldest person in group (including the persons that are alone in their group) with a row full of NULLs from b ('no biggest age in the group').</span></span><br><span class="line"><span class="comment">-- Using INNER JOIN makes these rows not matching and they are ignored.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- The WHERE clause keeps only the rows having NULLs in the fields extracted from b. They are the oldest persons from each group.</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 这个写法貌似也对？我理解不了这个写法 貌似和经典inner等价 https://stackoverflow.com/questions/8470311/get-the-latest-date-from-grouped-mysql-data</span></span><br><span class="line"><span class="keyword">SELECT</span> d.machine_id, d.heartbeat, d.cpu, d.memory <span class="keyword">FROM</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs d</span><br><span class="line"><span class="keyword">WHERE</span> d.heartbeat <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">max</span>(d2.heartbeat) <span class="keyword">FROM</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs d2 <span class="keyword">WHERE</span> d2.machine_id=d.machine_id)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--理解不了的写法二  和上面有点像 来自思否中Ewellyuan被质疑的回答  https://segmentfault.com/q/1010000004138670</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs <span class="keyword">as</span> u</span><br><span class="line"><span class="keyword">where</span> u.heartbeat = (<span class="keyword">select</span> <span class="keyword">max</span>(heartbeat)</span><br><span class="line">                     <span class="keyword">from</span> automated_task_center_test_wxj.atc_machine_heartbeat_logs</span><br><span class="line">                     <span class="keyword">where</span> machine_id = u.machine_id)</span><br></pre></td></tr></table></figure><p><a href="https://dev.mysql.com/doc/refman/5.7/en/example-maximum-column-group-row.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/example-maximum-column-group-row.html</a></p><p><a href="https://segmentfault.com/a/1190000004157112" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004157112</a></p><p><a href="https://stackoverflow.com/a/7745635" target="_blank" rel="noopener">https://stackoverflow.com/a/7745635</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个常见问题 这类问题有一个名字  greatest-n-per-group 可以在stackOverFlow上看到大量讨论&lt;/p&gt;
&lt;p&gt;分组中某栏最大好取 只要&lt;/p&gt;
&lt;p&gt;SELECT id, MAX(rev)&lt;br&gt;FROM YourTable&lt;br&gt;GROUP </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql not in GROUP BY clause and contains nonaggregated column</title>
    <link href="https://yiyayamaya.github.io/2021/10/25/mysql-not-in-GROUP-BY-clause-and-contains-nonaggregated-column/"/>
    <id>https://yiyayamaya.github.io/2021/10/25/mysql-not-in-GROUP-BY-clause-and-contains-nonaggregated-column/</id>
    <published>2021-10-25T02:28:37.000Z</published>
    <updated>2021-10-25T02:29:24.628Z</updated>
    
    <content type="html"><![CDATA[<p>这篇讲的很好<br><a href="https://www.twle.cn/t/654" target="_blank" rel="noopener">https://www.twle.cn/t/654</a></p><p>今天在做数据统计的时候遇到这个错误</p><p>MySQL： 1055 Expression #3 of SELECT list is not in GROUP BY clause and contains nonaggregated column<br>错误愿意大概是：SELECT 的字段列表没有包含在 GROUP BY 语句中</p><p>很多年之前都用的好好的，怎么就报错了呢！！！！</p><p>查了一下，哦，这又是 MySQL 5.7 的锅。</p><p>only_full_group_by<br>MySQL 其实很早就添加了 only_full_group_by 这个 sql_mode，但一直都作为可选项之一，并没有强制默认。</p><p>然而，MySQL 5.7 之后，only_full_group_by 成为 sql_mode 的默认选项之一</p><p>这就会让我们的一些惯性思维导致一系列的 SQL 错误</p><p>only_full_group_by 这个 sql_mode 的唯一要求，就是所有的 select 字段必须在 group by 字段中，否则必须出现在 SQL Aggregate 函数中，反过来却是非必须的</p><p>假设我们有下面一张表 employee</p><p>id    name    depart    depart_id    salary<br>1    小明    技术部    1    25000<br>2    小李    产品部    2    32000<br>3    小花    技术部    1    35000<br>4    小红    UI 部    3    28000<br>CREATE TABLE IF NOT EXISTS <code>employee</code>(<br>   <code>id</code> INT UNSIGNED AUTO_INCREMENT,<br>   <code>name</code> VARCHAR(64) NOT NULL,<br>   <code>depart</code> VARCHAR(128) NOT NULL,<br>   <code>depart_id</code> INT UNSIGNED NOT NULL,<br>   <code>salary</code> INT UNSIGNED NOT NULL,<br>   PRIMARY KEY ( <code>id</code> )<br>)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</p><p>INSERT INTO employee VALUES(1,’小明’,’技术部’,1,25000),(2,’小李’,’产品部’,2,32000),(3,’小花’,’技术部’,1,35000),(4,’小红’,’UI 部’,3,28000);<br>我们要查询每个部门的工资总和，然后又要显示部门名，一种不会触发 only_full_group_by 模式的方法是根据 depart 字段分组</p><p>select depart, sum(salary) from employee group by depart<br>输出结果如下</p><p>+———–+————-+<br>| depart    | sum(salary) |<br>+———–+————-+<br>| 技术部    |       60000 |<br>| 产品部    |       32000 |<br>| UI 部     |       28000 |<br>+———–+————-+<br>但如果我们一点加了 depart_id，那么就会立马报错</p><p>mysql&gt; select depart_id,depart, sum(salary) from employee group by depart;<br>ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column ‘demo.employee.depart_id’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by<br>为什么会这样？</p><p>因为字段既不在分组中也不在 Aggregate 函数中，那么在相同的分组中，这个字段的值可能是不同的，系统不知道要如何选择</p><p>解决办法<br>优化代码，剔除 select 语句中的多余字段，也就是不要触发 only_full_group_by。这是值得推荐的，因为这是写出好代码的必要添加之一。</p><p>告诉系统，你可以随意返回值，也就是使用 any_value() 函数来包装值</p><p>如果你必须要出现这个字段，那么这是推荐的方式</p><p>mysql&gt; select any_value(depart_id),depart, sum(salary) from employee group by depart;<br>+———————-+———–+————-+<br>| any_value(depart_id) | depart    | sum(salary) |<br>+———————-+———–+————-+<br>|                    1 | 技术部    |       60000 |<br>|                    2 | 产品部    |       32000 |<br>|                    3 | UI 部     |       28000 |<br>+———————-+———–+————-+<br>3 rows in set (0.00 sec)<br>关闭 sql_mode=ONLY_FULL_GROUP_BY。</p><p>在配置文件 my.cnf 中关闭 sql_mode=ONLY_FULL_GROUP_BY</p><p>这是最不推荐的方式！！！！！ 千万不要这么做</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇讲的很好&lt;br&gt;&lt;a href=&quot;https://www.twle.cn/t/654&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.twle.cn/t/654&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天在做数据统计的时候遇到这个错误&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql 存储过程</title>
    <link href="https://yiyayamaya.github.io/2021/10/06/mysql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://yiyayamaya.github.io/2021/10/06/mysql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2021-10-06T05:54:44.000Z</published>
    <updated>2021-10-06T05:56:36.554Z</updated>
    
    <content type="html"><![CDATA[<p>一次写的mysql造数据脚本 感觉写的不错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> function_test;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> function_test(event_arr <span class="built_in">varchar</span>(<span class="number">150</span>),retry_arr <span class="built_in">varchar</span>(<span class="number">150</span>),task_source_idVal <span class="built_in">INT</span>,rand_time  <span class="built_in">varchar</span>(<span class="number">25</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">DECLARE</span> event_arr_tmp <span class="built_in">varchar</span>(<span class="number">150</span>);</span><br><span class="line">    <span class="keyword">DECLARE</span> retry_arr_tmp <span class="built_in">varchar</span>(<span class="number">150</span>);</span><br><span class="line">    <span class="keyword">DECLARE</span> eventVal <span class="built_in">varchar</span>(<span class="number">150</span>);</span><br><span class="line">    <span class="keyword">DECLARE</span> retryVal <span class="built_in">varchar</span>(<span class="number">150</span>);</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> random_task_id <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> task_name_val_arr <span class="built_in">varchar</span>(<span class="number">1000</span>) <span class="keyword">default</span></span><br><span class="line"><span class="string">'mt_daily,'</span></span><br><span class="line"><span class="string">'mt_monthly,'</span></span><br><span class="line"><span class="string">'mt_b2b_monthly,'</span></span><br><span class="line"><span class="string">'returns_daily,'</span></span><br><span class="line"><span class="string">'returns_monthly,'</span></span><br><span class="line"><span class="string">'mt_summary_monthly,'</span></span><br><span class="line"><span class="string">'deal,'</span></span><br><span class="line"><span class="string">'deal_result,'</span></span><br><span class="line"><span class="string">'inventory_age,'</span></span><br><span class="line"><span class="string">'vat_monthly,'</span></span><br><span class="line"><span class="string">'business_daily,'</span></span><br><span class="line"><span class="string">'bank_card,'</span></span><br><span class="line"><span class="string">'box_upload,'</span></span><br><span class="line"><span class="string">'box_download,'</span></span><br><span class="line"><span class="string">'order_shoot,'</span></span><br><span class="line"><span class="string">'balance_daily,'</span></span><br><span class="line"><span class="string">'balance_quarterly,'</span></span><br><span class="line"><span class="string">'account_status,'</span></span><br><span class="line"><span class="string">'feedback_daily,'</span></span><br><span class="line"><span class="string">'request_review,'</span></span><br><span class="line"><span class="string">'storage_free_monthly,'</span></span><br><span class="line"><span class="string">'storage_mon_monthly,'</span></span><br><span class="line"><span class="string">'referenceid,'</span></span><br><span class="line"><span class="string">'amazon_rank,'</span></span><br><span class="line"><span class="string">'amazon_rating,'</span></span><br><span class="line"><span class="string">'walmart_rank,'</span></span><br><span class="line"><span class="string">'get_boss_positions_by_search,'</span></span><br><span class="line"><span class="string">'get_boss_positions_by_company,'</span></span><br><span class="line"><span class="string">'get_boss_position_detail,'</span></span><br><span class="line"><span class="string">'balance_monthly'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">DECLARE</span> task_name_val <span class="built_in">varchar</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">select</span> <span class="number">1</span> + (<span class="keyword">RAND</span>() * <span class="number">31</span>) <span class="keyword">into</span> random_task_id;</span><br><span class="line">            <span class="keyword">SET</span> task_name_val = SUBSTRING_INDEX(task_name_val_arr, <span class="string">','</span>, random_task_id);</span><br><span class="line">            <span class="keyword">SET</span> task_name_val = SUBSTRING_INDEX(task_name_val, <span class="string">','</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">SET</span> event_arr_tmp=event_arr;</span><br><span class="line">            <span class="keyword">SET</span> retry_arr_tmp=retry_arr;</span><br><span class="line">            WHILE event_arr_tmp != ''  <span class="keyword">DO</span></span><br><span class="line">                    <span class="keyword">SET</span> eventVal = SUBSTRING_INDEX(event_arr_tmp, <span class="string">','</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">SET</span> retryVal = SUBSTRING_INDEX(retry_arr_tmp, <span class="string">','</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> atc_task_logs(task_source_id, <span class="keyword">event</span>, result_hash_key, task_name, retry_times,</span><br><span class="line">                                              created_time)</span><br><span class="line">                    <span class="keyword">VALUES</span> (task_source_idVal, eventVal, <span class="number">0</span>, task_name_val, retryVal, rand_time);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">select</span> <span class="keyword">date_add</span>(rand_time, <span class="built_in">interval</span> <span class="number">1</span> <span class="keyword">second</span>) <span class="keyword">into</span> rand_time;</span><br><span class="line"></span><br><span class="line">                    IF LOCATE(',', event_arr_tmp) &gt; 0 THEN</span><br><span class="line">                        <span class="keyword">SET</span> event_arr_tmp = <span class="keyword">SUBSTRING</span>(event_arr_tmp, <span class="keyword">LOCATE</span>(<span class="string">','</span>, event_arr_tmp) + <span class="number">1</span>);</span><br><span class="line">                    ELSE</span><br><span class="line">                        <span class="keyword">SET</span> event_arr_tmp = <span class="string">''</span>;</span><br><span class="line">                    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">                    IF LOCATE(',', retry_arr_tmp) &gt; 0 THEN</span><br><span class="line">                        <span class="keyword">SET</span> retry_arr_tmp = <span class="keyword">SUBSTRING</span>(retry_arr_tmp, <span class="keyword">LOCATE</span>(<span class="string">','</span>, retry_arr_tmp) + <span class="number">1</span>);</span><br><span class="line">                    ELSE</span><br><span class="line">                        <span class="keyword">SET</span> retry_arr_tmp = <span class="string">''</span>;</span><br><span class="line">                    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> //</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> proc_batch_insert;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc_batch_insert()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> event_arr1 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,2,3,4'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> event_arr2 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,2,3,5,1,2,3,4'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> event_arr3 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,2,3,5,1,2,3,5,1,2,3,4'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> event_arr4 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,2,3,5,1,2,3,5,1,2,3,5,1,2,3,4'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> event_arr5 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,2,3,5,1,2,3,5,1,2,3,5,1,2,3,5,1,2,3,4'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> event_arr6 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,2,3,5,1,2,3,5,1,2,3,5,1,2,3,5,1,2,3,5'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">DECLARE</span> retry_arr1 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,1,1,1'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> retry_arr2 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,1,1,1,2,2,2,2'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> retry_arr3 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,1,1,1,2,2,2,2,3,3,3,3'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> retry_arr4 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> retry_arr5 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> retry_arr6 <span class="built_in">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="string">'1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">DECLARE</span> event_arr <span class="built_in">varchar</span>(<span class="number">150</span>);</span><br><span class="line">    <span class="keyword">DECLARE</span> retry_arr <span class="built_in">varchar</span>(<span class="number">150</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">DECLARE</span> task_source_idVal <span class="built_in">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">DECLARE</span> arr_index_probability_distribution <span class="built_in">varchar</span>(<span class="number">1000</span>) <span class="keyword">default</span></span><br><span class="line"><span class="string">'1,1,1,1,1,1,1,1,1,1,2,2,2,2,3,3,4,4,5,6,'</span></span><br><span class="line"><span class="string">'1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,'</span></span><br><span class="line"><span class="string">'1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,'</span></span><br><span class="line"><span class="string">'1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,'</span></span><br><span class="line"><span class="string">'1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">DECLARE</span>  arr_index_key <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span>  rand_time <span class="built_in">varchar</span>(<span class="number">25</span>) ;</span><br><span class="line">    <span class="keyword">DECLARE</span>  arr_value_value <span class="built_in">varchar</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">SET</span> task_source_idVal = <span class="number">3000001</span>;</span><br><span class="line"></span><br><span class="line">    WHILE task_source_idVal &lt;= 4000000 DO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="number">1</span> + (<span class="keyword">RAND</span>() * <span class="number">101</span>) <span class="keyword">into</span> arr_index_key;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> FROM_UNIXTIME(</span><br><span class="line">         <span class="keyword">FLOOR</span>((@s := <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2021-10-19 23:59:56'</span>)) + <span class="keyword">RAND</span>() * (<span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2021-10-14 23:59:59'</span>) - @s + <span class="number">1</span>)</span><br><span class="line">    )) <span class="keyword">into</span> rand_time  ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SET</span> arr_value_value = SUBSTRING_INDEX(arr_index_probability_distribution, <span class="string">','</span>, arr_index_key);</span><br><span class="line">    <span class="keyword">SET</span> arr_value_value = SUBSTRING_INDEX(arr_value_value, <span class="string">','</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CASE arr_value_value</span><br><span class="line">        WHEN '1' THEN <span class="keyword">SET</span> event_arr = event_arr1;</span><br><span class="line">                    <span class="keyword">SET</span> retry_arr = retry_arr1;</span><br><span class="line">        WHEN '2' THEN <span class="keyword">SET</span> event_arr = event_arr2;</span><br><span class="line">                    <span class="keyword">SET</span> retry_arr = retry_arr2;</span><br><span class="line">        WHEN '3' THEN <span class="keyword">SET</span> event_arr = event_arr3;</span><br><span class="line">                    <span class="keyword">SET</span> retry_arr = retry_arr3;</span><br><span class="line">        WHEN '4' THEN <span class="keyword">SET</span> event_arr = event_arr4;</span><br><span class="line">                    <span class="keyword">SET</span> retry_arr = retry_arr4;</span><br><span class="line">        WHEN '5' THEN <span class="keyword">SET</span> event_arr = event_arr5;</span><br><span class="line">                    <span class="keyword">SET</span> retry_arr = retry_arr5;</span><br><span class="line">        WHEN '6' THEN <span class="keyword">SET</span> event_arr = event_arr6;</span><br><span class="line">                    <span class="keyword">SET</span> retry_arr = retry_arr6;</span><br><span class="line">        ELSE <span class="keyword">BEGIN</span> <span class="keyword">END</span>;</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">call</span> function_test(event_arr,retry_arr,task_source_idVal,rand_time);</span><br><span class="line">    <span class="keyword">SET</span> task_source_idVal = task_source_idVal + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">SET</span> i = i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">//</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> proc_batch_insert();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一次写的mysql造数据脚本 感觉写的不错&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>全局变量 局部变量的生命周期</title>
    <link href="https://yiyayamaya.github.io/2021/09/18/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://yiyayamaya.github.io/2021/09/18/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-09-18T03:35:38.000Z</published>
    <updated>2021-09-18T03:39:00.215Z</updated>
    
    <content type="html"><![CDATA[<p>先开个坑 起因是python中的一个例子</p><p>下面的代码运行完后driver(浏览器窗口)不加driver.quit()也会自己退出，可能是因为局部变量被回收了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_driver</span><span class="params">()</span>:</span></span><br><span class="line">    driver=xxx</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    create_driver()</span><br></pre></td></tr></table></figure><p>改成这样的全局就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">driver=<span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_driver</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> driver</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    create_driver()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先开个坑 起因是python中的一个例子&lt;/p&gt;
&lt;p&gt;下面的代码运行完后driver(浏览器窗口)不加driver.quit()也会自己退出，可能是因为局部变量被回收了&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>尝试自己编译clash顺便docker入门</title>
    <link href="https://yiyayamaya.github.io/2021/09/15/%E5%B0%9D%E8%AF%95%E8%87%AA%E5%B7%B1%E7%BC%96%E8%AF%91clash%E9%A1%BA%E4%BE%BFdocker%E5%85%A5%E9%97%A8/"/>
    <id>https://yiyayamaya.github.io/2021/09/15/%E5%B0%9D%E8%AF%95%E8%87%AA%E5%B7%B1%E7%BC%96%E8%AF%91clash%E9%A1%BA%E4%BE%BFdocker%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-15T07:37:29.000Z</published>
    <updated>2021-09-15T09:23:52.560Z</updated>
    
    <content type="html"><![CDATA[<p>镜像是文件，容器是进程<br>$ docker ps // 查看所有正在运行容器<br>$ docker stop containerId // containerId 是容器的ID  </p><p>$ docker ps -a // 查看所有容器<br>$ docker ps -a -q // 查看所有容器ID  </p><p>$ docker stop $(docker ps -a -q) //  stop停止所有容器<br>$ docker  rm $(docker ps -a -q) //   remove删除所有容器   </p><p>查看所有镜像<br>docker images  </p><p>docker run为镜像创建一个容器</p><p>可以利用 docker container start 命令，直接将一个已经终止（exited）的容器启动运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;镜像是文件，容器是进程&lt;br&gt;$ docker ps // 查看所有正在运行容器&lt;br&gt;$ docker stop containerId // containerId 是容器的ID  &lt;/p&gt;
&lt;p&gt;$ docker ps -a // 查看所有容器&lt;br&gt;$ docker</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql 分页</title>
    <link href="https://yiyayamaya.github.io/2021/09/07/mysql-%E5%88%86%E9%A1%B5/"/>
    <id>https://yiyayamaya.github.io/2021/09/07/mysql-%E5%88%86%E9%A1%B5/</id>
    <published>2021-09-07T09:49:53.000Z</published>
    <updated>2021-09-11T03:44:58.785Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 百万级数据量分页查询方法及其优化</p><p><a href="https://www.huaweicloud.com/articles/7cb1402c2d18baedfa12dd610ff2eaac.html" target="_blank" rel="noopener">https://www.huaweicloud.com/articles/7cb1402c2d18baedfa12dd610ff2eaac.html</a></p><p>在使用Mybatis时，最头痛的就是写分页了，需要先写一个查询count的select语句，然后再写一个真正分页查询(limit)的语句<a href="https://blog.csdn.net/Agly_Clarlie/article/details/53185750" target="_blank" rel="noopener">https://blog.csdn.net/Agly_Clarlie/article/details/53185750</a><br>猜想结合pagehelper会容易 但是怎么结合呢？ 有前端的从前端发送pageNum pageSize的我会 name无前端的呢</p><p>无前端 单纯想要批量查询 结合pagehelper如何使用 ?<br>参考了这个<a href="https://blog.csdn.net/a_c_c_a/article/details/106060621" target="_blank" rel="noopener">https://blog.csdn.net/a_c_c_a/article/details/106060621</a> 可以通过pageInfo.getPages()得到总页数 结束pageNum的遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pageNum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pageSize =<span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">    PageHelper.startPage(pageNum, pageSize);  <span class="comment">// TODO 不count的话下面就得不到pageInfo.getTotal()</span></span><br><span class="line">    List&lt;Machine&gt; machineListPart = machineDao.getMachineAll();</span><br><span class="line">    PageInfo&lt;Machine&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(machineListPart);</span><br><span class="line">    System.out.println(</span><br><span class="line">            <span class="string">" 当前页数["</span>+pageNum</span><br><span class="line">            +<span class="string">"],页大小["</span>+pageInfo.getPageSize()</span><br><span class="line">            +<span class="string">"],总页数["</span>+pageInfo.getPages()</span><br><span class="line">            +<span class="string">"],总记录数["</span>+pageInfo.getTotal()+<span class="string">"]"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pageInfo.getPageNum()&gt;=pageInfo.getPages())&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pageNum++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">网元参数迁移 当前页数[1],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[2],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[3],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[4],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[5],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[6],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[7],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[8],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[9],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[10],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">...</span><br><span class="line">网元参数迁移 当前页数[100],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[101],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[102],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[103],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[104],页大小[10000],当页大小[10000],总页数[105],总记录数[1040376]</span><br><span class="line">网元参数迁移 当前页数[105],页大小[10000],当页大小[376],总页数[105],总记录数[1040376]</span><br></pre></td></tr></table></figure><p>但是上述pagehelper也是通过limit简单实现 </p><p>可以利用索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pageIdIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pageSize=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> totalNum=machineDao.getMachineNum();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            List&lt;Machine&gt; machineListPart = machineDao.getMachineAllBetter(pageIdIndex,pageSize);</span><br><span class="line">            pageIdIndex+=pageSize;</span><br><span class="line">            <span class="keyword">if</span> (pageIdIndex&gt;totalNum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>未完待续</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL 百万级数据量分页查询方法及其优化&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.huaweicloud.com/articles/7cb1402c2d18baedfa12dd610ff2eaac.html&quot; target=&quot;_blank&quot; rel=&quot;n</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java中super()的用法</title>
    <link href="https://yiyayamaya.github.io/2021/09/07/java%E4%B8%ADsuper-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://yiyayamaya.github.io/2021/09/07/java%E4%B8%ADsuper-%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2021-09-07T06:53:32.000Z</published>
    <updated>2021-09-07T07:08:41.047Z</updated>
    
    <content type="html"><![CDATA[<p>va继承中，经常会碰上super()方法，今天恰好碰上，小小的研究了一下。</p><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><p>在子类的构造方法的第一行，必须是第一行调用super()，这样就调用了父类的构造方法，如果父类有多个不同的构造方法，则根据调用super()时传入的参数调</p><p>顺便记录下关于Java继承中构造方法的一些东西：<br>在调用子类构造方法时，不管调用的是有参还    是无参，如果没有在第一行调用super(var xx)，都会默认先调用父类的无参构造方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;va继承中，经常会碰上super()方法，今天恰好碰上，小小的研究了一下。&lt;/p&gt;
&lt;p&gt;super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。&lt;/p&gt;
&lt;p&gt;在子类的构造方法的第一行，必须是第一行调用super()，这样就调用了父类</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>$.post可以说是缩写版的$.ajax</title>
    <link href="https://yiyayamaya.github.io/2021/08/24/post%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E7%BC%A9%E5%86%99%E7%89%88%E7%9A%84-ajax/"/>
    <id>https://yiyayamaya.github.io/2021/08/24/post%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E7%BC%A9%E5%86%99%E7%89%88%E7%9A%84-ajax/</id>
    <published>2021-08-24T08:07:02.000Z</published>
    <updated>2021-08-24T08:11:07.455Z</updated>
    
    <content type="html"><![CDATA[<p>石锤了 官方说法 总忘 水了一篇文章</p><img src="/2021/08/24/post%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E7%BC%A9%E5%86%99%E7%89%88%E7%9A%84-ajax/2021-08-24_16-09.png" class="" title="This is an example image">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;石锤了 官方说法 总忘 水了一篇文章&lt;/p&gt;
&lt;img src=&quot;/2021/08/24/post%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E7%BC%A9%E5%86%99%E7%89%88%E7%9A%84-ajax/2021-08-24</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql 外键 ON DELETE CASCADE</title>
    <link href="https://yiyayamaya.github.io/2021/08/24/mysql-%E5%A4%96%E9%94%AE-ON-DELETE-CASCADE/"/>
    <id>https://yiyayamaya.github.io/2021/08/24/mysql-%E5%A4%96%E9%94%AE-ON-DELETE-CASCADE/</id>
    <published>2021-08-24T06:35:34.000Z</published>
    <updated>2021-08-24T06:47:20.430Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.yiibai.com/mysql/foreign-key.html" target="_blank" rel="noopener">https://www.yiibai.com/mysql/foreign-key.html</a></p><p><a href="https://www.yiibai.com/mysql/on-delete-cascade.html" target="_blank" rel="noopener">https://www.yiibai.com/mysql/on-delete-cascade.html</a></p><p>假设有两张表：建筑物(buildings)和房间(rooms)。 在这个数据库模型中，每个建筑物都有一个或多个房间。 然而，每个房间只属于一个建筑物。没有建筑物则房间是不会存在的。</p><p>当我们从buildings表中删除一行时，还要删除rooms表中引用建筑物表中行的行。 </p><p>我们希望rooms表中涉及到建筑物编号2的行记录也将被删除(讲得通俗一点：假设2号楼倒塌了，那么2号楼的房间应该也就不存在了)。以下是演示MySQL ON DELETE CASCADE参考操作如何工作的步骤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">USE</span> testdb;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> rooms (</span><br><span class="line">    room_no <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    room_name <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    building_no <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (building_no)</span><br><span class="line">        <span class="keyword">REFERENCES</span> buildings (building_no)</span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>为何说外键有性能问题：1.数据库需要维护外键的内部管理；2.外键等于把数据的一致性事务实现，全部交给数据库服务器完成；3.有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源；4.外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.yiibai.com/mysql/foreign-key.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.yiibai.com/mysql/foreign-key.html&lt;/a&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一次前端父页面向子页面传值的思考</title>
    <link href="https://yiyayamaya.github.io/2021/08/24/%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AF%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%90%91%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://yiyayamaya.github.io/2021/08/24/%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AF%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%90%91%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2021-08-24T05:42:15.000Z</published>
    <updated>2021-08-24T05:52:01.731Z</updated>
    
    <content type="html"><![CDATA[<img src="/2021/08/24/%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AF%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%90%91%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%E7%9A%84%E6%80%9D%E8%80%83/tutieshi_640x360_4s.gif" class="" title="This is an example image"><p>点开的新窗口的一个值是从父页面传进子页面的值而不是子页面异步获取的<br>这种东西通常不能在子里面修改 如果嗯要修改<br>一、需要刷新父<br>刷新父亲的两种方法1.reload 2.不reload 单纯改值<br>二、要么不要传 用子异步请求</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2021/08/24/%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AF%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%90%91%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>jquery 学习</title>
    <link href="https://yiyayamaya.github.io/2021/08/22/jquery-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yiyayamaya.github.io/2021/08/22/jquery-%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-08-22T06:04:01.000Z</published>
    <updated>2021-08-23T03:57:21.316Z</updated>
    
    <content type="html"><![CDATA[<p>jquery 对象 vs dom对象<br>用#id作为选择符取得的是jQuery对象与document.getElementById(“id”)得到的DOM对象，这两者并不等价。</p><p>(一)jQuery对象是一个数据对象，可以通过[index]的方法，来得到相应的DOM对象。<br>例：</p><p>var $v =$(“#v”) ; //jQuery对象</p><p>var v=$v[0]; //DOM对象</p><p>alert(v.checked) //检测这个checkbox是否被选中</p><p>var $email = $(“#email”); // refers to the jQuery object representation of the dom object<br>var email_field = $(“#email”).get(0); // refers to the dom object itself</p><p>仅仅是变量名的一种规范</p><p>注：jquery对象命名时，通常以$开头，比如 var $ps = $(‘p’)，这样的好处是，一眼就知道$ps是一个jquery对象，程序可读性大大提高。<br>————————————<br>jquery选择器返回多个还是一个</p><p>一、当使用id选择器时，会返回对应的jquery对象</p><p>let files = $(“#uploadFile_batchImport”);<br>let file = files[0].files[0];<br>以上代码中，files是jquery对象，files[0]是dom元素，file则是dom元素的files属性的第一个文件。<br>二、当使用类选择器时，返回的是多个dom对象组成的jquery对象<br>let obj = $(“.intro”);</p><p>let aDom = obj[0];</p><p>此时，obj是多个dom元素组成的jquery对象，aDom是个dom对象。</p><p>[attribute]    $(“[href]”)    具有href属性的所有元素</p><p>[attribute=value]    $(“[href=’default.htm’]”)    href属性值等于“default.htm”的所有元素</p><p>$(“p”) 选取 <p> 元素。</p><p>$(“p.intro”) 选取所有 class=”intro” 的 <p> 元素。</p><p>$(“p#demo”) 选取所有 id=”demo” 的 <p> 元素。</p><p>jQuery 使用 XPath 表达式来选择带有给定属性的元素。</p><p>$(“[href]”) 选取所有带有 href 属性的元素。</p><p>$(“[href=’#’]”) 选取所有带有 href 值等于 “#” 的元素。</p><p>$(“[href!=’#’]”) 选取所有带有 href 值不等于 “#” 的元素。</p><p>$(“[href$=’.jpg’]”) 选取所有 href 值以 “.jpg” 结尾的元素。</p><p>按tag查找 按class查找 按属性查找 组合查找 多项选择器</p><p>层级选择器（Descendant Selector）<br>如果两个DOM元素具有层级关系，就可以用$(‘ancestor descendant’)来选择，层级之间用空格隔开。例如：</p><p>子选择器（Child Selector）</p><p>.find()<br>.parent()方法</p><p>parent()是唯一的，为什么可以加selector呢？<br>本方法也可以接受一个字符串选择器，用于筛选返回的元素。</p><p>本方法用于选择给定jQuery对象中包含的DOM元素或者DOM元素集的祖先节点，并将这些节点包装成jQuery对象返回，返回的节点集是以从里到外的顺序排序的。</p><p>parents()同理</p><p>这里我们看到有一个prevObject，这个this.prevObject到底是用来干什么的呢？没错，jQuery通过这个属性维护了一个jQuery对象栈，只要我们使用选择相关的方法（如find()，eq()等）获取新的jQuery对象，jQuery就会把之前的对象存储在prevObject中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;jquery 对象 vs dom对象&lt;br&gt;用#id作为选择符取得的是jQuery对象与document.getElementById(“id”)得到的DOM对象，这两者并不等价。&lt;/p&gt;
&lt;p&gt;(一)jQuery对象是一个数据对象，可以通过[index]的方法，来得到相应</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>form表单中button type是button而不是submit</title>
    <link href="https://yiyayamaya.github.io/2021/08/12/form%E8%A1%A8%E5%8D%95%E4%B8%ADbutton-type%E6%98%AFbutton%E8%80%8C%E4%B8%8D%E6%98%AFsubmit/"/>
    <id>https://yiyayamaya.github.io/2021/08/12/form%E8%A1%A8%E5%8D%95%E4%B8%ADbutton-type%E6%98%AFbutton%E8%80%8C%E4%B8%8D%E6%98%AFsubmit/</id>
    <published>2021-08-12T01:41:34.000Z</published>
    <updated>2021-08-24T06:03:07.117Z</updated>
    
    <content type="html"><![CDATA[<p>遇到了一个需求和这个楼主一抹一样。   <a href="https://segmentfault.com/q/1010000005039644" target="_blank" rel="noopener">https://segmentfault.com/q/1010000005039644</a></p><p>因为是通过ajax请求服务器来实现登录的，所以我没有用button type=”submit”，但是现在问题是如果type是button的话，就不能实现敲回车自动触发按钮的功能了，我想做到在输入框里敲一下回车就自动触发登录的功能，请问该如何实现啊？</p><p>换回 type=”submit”，在 form 的 onsubmit 事件中触发 AJAX 请求，并 event.preventDefault() 就可以了。</p><p>顺便看到了一篇白话解释 Javascript事件preventDefault,stopPropagation及return false的区别<br><a href="https://segmentfault.com/a/1190000008227026" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008227026</a><br>讲得很好。提到了一下javascript中两种事件传播模式:捕获模式(capturing)冒泡模式(bubbling)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;遇到了一个需求和这个楼主一抹一样。   &lt;a href=&quot;https://segmentfault.com/q/1010000005039644&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/q/10100</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>通过一次线上问题排查内存过大来学习jvm基础</title>
    <link href="https://yiyayamaya.github.io/2021/07/29/%E9%80%9A%E8%BF%87%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E8%BF%87%E5%A4%A7%E6%9D%A5%E5%AD%A6%E4%B9%A0jvm%E5%9F%BA%E7%A1%80/"/>
    <id>https://yiyayamaya.github.io/2021/07/29/%E9%80%9A%E8%BF%87%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E8%BF%87%E5%A4%A7%E6%9D%A5%E5%AD%A6%E4%B9%A0jvm%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-29T06:31:35.000Z</published>
    <updated>2021-08-02T08:26:35.699Z</updated>
    
    <content type="html"><![CDATA[<p>用到的工具 jmap jstack jvisualvm现在叫visualVM MAT JConsole </p><p>生成的dump文件可以用jhat分析</p><p>jmap命令将程序的内存数据保存下来，jmap -dump:live,format=b,file=m.hprof PID</p><p>然后我指着监控信息，让运维看：“大哥你看这监控历史，堆内存是达到过 6G 的，只是后面 GC 了，没问题啊！”</p><p>“JVM 的垃圾回收，只是一个逻辑上的回收，回收的只是 JVM 申请的那一块逻辑堆区域，将数据标记为空闲之类的操作，不是调用 free 将内存归还给操作系统”</p><p>JVM 的自动内存管理，其实只是先向操作系统申请了一大块内存，然后自己在这块已申请的内存区域中进行“自动内存管理”。JAVA 中的对象在创建前，会先从这块申请的一大块内存中划分出一部分来给这个对象使用，在 GC 时也只是这个对象所处的内存区域数据清空，标记为空闲而已</p><p>运维：“原来是这样，那按你的意思，JVM 就不会将 GC 回收后的空闲内存还给操作系统了吗？”</p><p>JVM 还是会归还内存给操作系统的，只是因为这个代价比较大，所以不会轻易进行。而且不同垃圾回收器 的内存分配算法不同，归还内存的代价也不同。</p><p>java加jvm参数正确格式应该是nohup java -Xms800m -Xmx800m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxNewSize=512m -jar 你的jar包 &gt;&gt;/dev/null &amp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_131&#x2F;bin&#x2F;java -jar -server -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;dump&#x2F;heap&#x2F;</span><br><span class="line"> -Djava.io.tmpdir&#x3D;&#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;tmp&#x2F; </span><br><span class="line"> -Dserver.port&#x3D;8103 </span><br><span class="line"> -Dcom.sun.management.jmxremote</span><br><span class="line"> -Dcom.sun.management.jmxremote.port&#x3D;5103 </span><br><span class="line"> -Dcom.sun.management.jmxremote.rmi.port&#x3D;6103 </span><br><span class="line"> -Dcom.sun.management.jmxremote.authenticate&#x3D;false </span><br><span class="line"> -Dcom.sun.management.jmxremote.ssl&#x3D;false </span><br><span class="line"> -Dcom.sun.management.jmxremote.access.file&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;management&#x2F;jmxremote.access </span><br><span class="line"> -Xmx2G -Xms2G -XX:+DisableExplicitGC -verbose:gc -Xloggc:&#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;log&#x2F;gc.%t.log -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTaskTimeStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps </span><br><span class="line"> -Dserver.connection-timeout&#x3D;60000 </span><br><span class="line"> -Dserver.tomcat.accept-count&#x3D;1000 </span><br><span class="line"> -Dserver.tomcat.max-threads&#x3D;300 </span><br><span class="line"> -Dserver.tomcat.min-spare-threads&#x3D;65 </span><br><span class="line"> -Dserver.tomcat.accesslog.enabled&#x3D;false </span><br><span class="line"> -Dserver.tomcat.accesslog.directory&#x3D;&#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;log&#x2F; </span><br><span class="line"> -Dserver.tomcat.accesslog.prefix&#x3D;access_log </span><br><span class="line"> -Dserver.tomcat.accesslog.pattern&#x3D;combine </span><br><span class="line"> -Dserver.tomcat.accesslog.suffix&#x3D;.log </span><br><span class="line"> -Dserver.tomcat.accesslog.rotate&#x3D;true </span><br><span class="line"> -Dserver.tomcat.accesslog.rename-on-rotate&#x3D;true </span><br><span class="line"> -Dserver.tomcat.accesslog.request-attributes-enabled&#x3D;true </span><br><span class="line"> -Dserver.tomcat.accesslog.buffered&#x3D;true </span><br><span class="line"> -XX:NewRatio&#x3D;4 -XX:SurvivorRatio&#x3D;30 -XX:TargetSurvivorRatio&#x3D;90 -XX:MaxTenuringThreshold&#x3D;8 -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction&#x3D;70 -XX:ParallelGCThreads&#x3D;24 -XX:ConcGCThreads&#x3D;24 -XX:-UseGCOverheadLimit -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction&#x3D;1 -XX:+CMSParallelRemarkEnabled -XX:+CMSScavengeBeforeRemark -XX:+ParallelRefProcEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSMaxAbortablePrecleanTime&#x3D;6000 -XX:CompileThreshold&#x3D;10 -XX:MaxInlineSize&#x3D;1024 -Dsun.net.client.defaultConnectTimeout&#x3D;60000 </span><br><span class="line"> -Dsun.net.client.defaultReadTimeout&#x3D;60000 </span><br><span class="line"> -Dnetworkaddress.cache.ttl&#x3D;300 -Dsun.net.inetaddr.ttl&#x3D;300 </span><br><span class="line"> -Djsse.enableCBCProtection&#x3D;false </span><br><span class="line"> -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom </span><br><span class="line"> -Dfile.encoding&#x3D;UTF-8 </span><br><span class="line"> -Dlog.path&#x3D;&#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;log&#x2F; </span><br><span class="line"> -Dspring.profiles.active&#x3D;online  </span><br><span class="line"> &#x2F;data&#x2F;spb_zcmweb&#x2F;8103&#x2F;deploy&#x2F;zcmweb.jar zcmweb</span><br></pre></td></tr></table></figure><p>最后xxx.jar 后面加–spring.config.location</p><p>jmap指定<br>-heap：打印jvm heap的情况<br>-histo：打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。<br>-histo:live ：同上，但是只答应存活对象的情况<br>-permstat：打印permanent generation heap情况</p><p>jmap -histo 18473 | head -30<br>jmap -histo 18473 | tail -30 </p><p>/home/wxj/Documents/Hexo-source-files/source/_posts/通过一次线上问题排查内存过大来学习jvm基础/2021-07-30_11-41.png</p><p>从打印结果可看出，类名中存在[C、[B等内容，只知道它占用了那么大的内存，但不知道由什么对象创建的。下一步需要将其他dump出来，使用内存分析工具进一步明确它是由谁引用的、由什么对象。</p><p>Heap Dump 是Java进程所使用的内存情况在某一时间的一次快照。 以文件的形式持久化到磁盘中。 </p><p>分析dump文件的几种方式<br>1、visualVM<br>2、MAT<br>3、jhat 15397.hprof (去localhost:7000查看)</p><p>插入内容：JDK命令行（jps、jstat、jinfo、jmap、jhat、jstack、jstatd、hprof）与JConsole<br><a href="https://www.huaweicloud.com/articles/9871161f404d4e817e18db0f40e815a1.html" target="_blank" rel="noopener">https://www.huaweicloud.com/articles/9871161f404d4e817e18db0f40e815a1.html</a></p><p>看本身大小时，占大头的都是char[] ,byte[]之类的，没什么意思（用jmap -histo:live pid 看的也是本身大小）。所以需要关心的是保留大小比较大的对象，看谁在引用这些char[], byte[]。</p><p>(MAT能看的信息更多，但VisualVM胜在JVM自带，用法如下：命令行输入jvisualvm，文件-&gt;装入-&gt;堆Dump－&gt;检查 -&gt; 查找20保留大小最大的对象，就会触发保留大小的计算，然后就可以类视图里浏览，按保留大小排序了)</p><p>可以从这个图看出这个类java.lang.ref.Finalizer占用500多M，表示这其中很多不能够被回对象的对象，此时点开hisgogram视图，并通过Retained Heap进行排序，如下截图：</p><p>从图中可以看出，被线线框圈起来的三个对象占用量非常大，那说明这几个大的对象并没有被释放，那现在就可以有针对性的从代码中去找这几个对象为什么没有被释放了。<br>再切换到dominator_tree视图：</p><p>这里可以看到velocity渲染也存在着问题，以及数据库的请求也比较多。</p><p><a href="https://blog.51cto.com/supercharles888/1347144" target="_blank" rel="noopener">https://blog.51cto.com/supercharles888/1347144</a> 讲了shallow size Retained size区别<br>Shallow Size是对象本身占据的内存的大小，不包含其引用的对象。对于常规对象（非数组）的Shallow Size由其成员变量的数量和类型来定，而数组的ShallowSize由数组类型和数组长度来决定，它为数组元素大小的总和。</p><p>Retained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C,C就是间接引用) ，并且排除被GC Roots直接或者间接引用的对象</p><p>Incoming references被什么实例引用了 和 Outgoing references引用了什么实例</p><p>一般来说，如果浅堆比较小，但是深堆比较大，那么这种对象比较可疑，首先找到深堆大的对象，然后通过incoming查看哪些对象引用这个对象，通过outgoing查看这个对象内部都有哪些对象</p><p>不确定这行写的对：dominator_tree中这两个值与Histogram中的区别是：dominator_tree基于实例的角度，而historgram基于类的角度</p><p>X86是一种架构，但是他有32位的和64位的！<br>32位的叫x86 ，后来出现基于它的64位版，就叫X86-64，后来有时简称X64。</p><p>Histogram是类粒度的，可以找到哪个类占用的堆内存比较多；dominator tree是对象粒度的，可以用来查看哪个对象引起占用堆内存比较大。选择dominator tree以后可以 group by class 就能按class看了！！！但是可能是因为unreachable 的原因，数目对不上。</p><p>升级版 JConsole 即 jvisualvm 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用到的工具 jmap jstack jvisualvm现在叫visualVM MAT JConsole &lt;/p&gt;
&lt;p&gt;生成的dump文件可以用jhat分析&lt;/p&gt;
&lt;p&gt;jmap命令将程序的内存数据保存下来，jmap -dump:live,format=b,file=m.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java 多线程学习</title>
    <link href="https://yiyayamaya.github.io/2021/07/22/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yiyayamaya.github.io/2021/07/22/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-22T03:28:26.000Z</published>
    <updated>2021-07-26T06:06:17.329Z</updated>
    
    <content type="html"><![CDATA[<p>先看廖雪峰<br><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185</a><br>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。<br>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。<br>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。 </p><p>一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><hr><p>改看王道的os了<br><a href="https://www.bilibili.com/video/BV1YE411D7nH?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=8</a><br>进程由程序段数据段PCB三部分组成</p><p>寄存器与内存的区别</p><p>load某内存地址的值放入某寄存器a<br>load某内存地址的值放入某寄存器b<br>运算a+b结果放到寄存器c<br>把寄存器c的值保存到某内存(存放运算结果)</p><p>1.如果是说有没有一条指令可以完成读内存 计算 再把结果写回内存 那显然是有的。x86的运算指令就可以用内存数据当运算对象</p><ol start="2"><li>如果是更lower level一点 对于微指令 绝大部分情况下是没有直接在内存数据上计算的. 通常应该是用load把内存数据都到register 然后在register上进行运算。对于risc来说, 这些每一个操作其实大都是一条汇编指令</li></ol><p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p><p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p><p><a href="https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html</a><br>阮一峰写的 堆内存栈内存什么的 挺好的</p><p>数据结构中的堆和内存中的堆是两个完全不同的概念  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">return</span> add_a_and_b(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stack memory 个人理解：因为其后进先出的方式得到了stack这样的名字，另一个内存会在函数退出时自动且非常有效地回收。Stack 是由于函数运行而临时占用的内存区域。上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。</p><p>基于堆的内存分配，也称为动态内存分配。程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。比如新建对象，或者使用malloc命令。从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><p>(不一定对)一般来说，每个线程分配一个stack，每个进程分配一个heap。</p><p>操作系统帧frame是什么</p><p>核心态 用户态</p><p>pv操作</p><p>王道考研操作系统 三层调度没听懂</p><p>单标志法</p><p>忙等待：指在单CPU情况下，一个进程进入临界区之后，其他进程因无法满足竞争条件而循环探测竞争条件。其缺点是，在单CPU情况下，等待进程循环探测竞争条件，浪费了时间片。</p><p>为什么生产者消费者的两个p操作不能换</p><p>实现互斥的p操作要放在实现同步的p操作之后。<br>两个v操作顺序可以交换</p><p>多消费者 吸烟者问题没听懂</p><p>github上XvTianYuan翻译的操作系统恐龙书第十版。<br>线程时CPU利用的基本单元；它包含一个线程ID，程序计数器(PC)，一个寄存器集(寄存器不是在cpu里么)和栈。一个线程与其他属于同一个进程的线程共享代码段和操作系统资源，如打开的文件和信号。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先看廖雪峰&lt;br&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.liaoxuef</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java synchronized</title>
    <link href="https://yiyayamaya.github.io/2021/07/13/java-synchronized/"/>
    <id>https://yiyayamaya.github.io/2021/07/13/java-synchronized/</id>
    <published>2021-07-13T06:36:29.000Z</published>
    <updated>2021-10-15T09:54:50.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当一个线程访问同步代码块时，首先是需要得到锁才能执行  </p></blockquote><blockquote><p>其实“锁”本身是个对象，synchronized这个关键字并不是“锁”。<br>从语法上讲，Java中的每个对象都可以看做一把锁，在HotSpot JVM实现中，锁有个专门的名字：监视器（Monitor）。<br>Monitor对象存在于每个Java对象的对象头中，这也是为什么Java中任意对象可以作为锁的原因，有关Monitor后续会详细介绍，有了这些概念看下面这张图应该就容易多了。</p></blockquote><img src="/2021/07/13/java-synchronized/1.jpeg" class="" title="This is an example image"><p>一个对象中有两个<font color=red>实例</font>方法同时被synchronized，则同一个对象，调用这两个方法时，只能同时执行一个。<br>原因：翻看相关书籍，发现jvm在执行方法以前，如果发现该方法前面有对象的synchronized关键字，就现在该对象的ID上加锁，当其他线程执行同时执行这个方法时，会检测改对象ＩＤ上是否加锁，如果加锁时就等待锁释放。 </p><p>Java Thread acquires an object level lock when it enters into an instance synchronized java method and acquires a class level lock when it enters into static synchronized java method.  </p><p>如果是<font color=red>静态</font>的方法呢？<br><a href="https://stackoverflow.com/questions/15438727/if-i-synchronized-two-methods-on-the-same-class-can-they-run-simultaneously" target="_blank" rel="noopener">https://stackoverflow.com/questions/15438727/if-i-synchronized-two-methods-on-the-same-class-can-they-run-simultaneously</a><br>静态方法使用.class上的锁。如果class A  {static synchronized void m() {} }，然后 new A().m()会锁住新的A()对象，此时别人调用A.m()需要的是A.class的锁但现在没有这样的锁，所以不会互相阻塞。所以永远不要实例化对象来调用静态方法。<br>Have in mind that static methods use lock on .class object. So if you have class A {static synchronized void m() {} }. And then one thread calls new A().m() it acquires lock on new A() object. If then another thread calls A.m() it ENTERS THE METHOD NO PROBLEM because what it looks for is lock on A.class object while NO THREADS possess this kind of lock. So even though you declared method synchronized it actualy IS accessed by two different threads AT THE SAME TIME. Thus: never use object references to call static methods</p><p>Putting synchronized on an instance method means that the thread has to acquire the lock (the “intrinsic lock”) on the object instance that the method is called on before the thread can start executing any code in that method.<font color=red>把synchronized放一个实例方法上意味着，该线程必须获取关于对象实例锁（以下简称“本征锁”），该方法被调用之前线程可以开始在该方法中执行的任何代码。</font></p><hr><p>5:35 PM Friday, October 15, 2021更新</p><p>有一个单例类FTPClientUtils里面全是静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">FTPClientUtils</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">switchToDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOutputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">Upload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>有一个Service里有一个上传文件的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">upload</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    FTPClientUtils.getInstance();<span class="comment">//确认ftpclient实例可用</span></span><br><span class="line">    FTPClientUtils.switchToDir();<span class="comment">//切换至目录</span></span><br><span class="line">    FTPClientUtils.getOutputStream();<span class="comment">//创建文件流</span></span><br><span class="line">    FTPClientUtils.UploadStream();<span class="comment">//传输流</span></span><br><span class="line">    FTPClientUtils.finishStream();<span class="comment">//切断文件流</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有静态方法都在竞争同一个class锁</p><p>问题是：如果在Upload()过程中，执行其他方法。在Upload()结束后放下锁，希望finish()立刻得到锁，结果被外面的getInstance()抢到了，又因为没关闭的文件流导致getInstance()阻塞，造成了死锁。</p><p>解决办法一：把service中的upload()加代码块锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">upload</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(FTPClientUtils<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">        FTPClientUtils.getInstance();<span class="comment">//确认ftpclient实例可用</span></span><br><span class="line">        FTPClientUtils.switchToDir();<span class="comment">//切换至目录</span></span><br><span class="line">        FTPClientUtils.getOutputStream();<span class="comment">//创建文件流</span></span><br><span class="line">        FTPClientUtils.UploadStream();<span class="comment">//传输流</span></span><br><span class="line">        FTPClientUtils.finishStream();<span class="comment">//切断文件流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法二：在FTPClientUtils中新建一个静态加锁方法，并把五个方法五合一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">FTPClientUtils</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">switchToDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOutputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">Upload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">upload</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        getInstance();</span><br><span class="line">        switchToDir();</span><br><span class="line">        getOutputStream();</span><br><span class="line">        Upload();</span><br><span class="line">        finish();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;当一个线程访问同步代码块时，首先是需要得到锁才能执行  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;其实“锁”本身是个对象，synchronized这个关键字并不是“锁”。&lt;br&gt;从语法上讲，Java中的每个对象都可以看做</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java 异常</title>
    <link href="https://yiyayamaya.github.io/2021/07/12/java-%E5%BC%82%E5%B8%B8/"/>
    <id>https://yiyayamaya.github.io/2021/07/12/java-%E5%BC%82%E5%B8%B8/</id>
    <published>2021-07-12T05:54:22.000Z</published>
    <updated>2021-07-12T06:22:45.547Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我怎么隐隐约约觉得写过异常相关的文章 但是找不到了。  </p></blockquote><img src="/2021/07/12/java-%E5%BC%82%E5%B8%B8/1.png" class="" title="This is an example image"><ul><li><p>Error是内存不足这种。</p></li><li><p>Exception：分为未检查异常(RuntimeException)和已检查异常(非RuntimeException)</p><ul><li>checkedException ：受检查的异常，这种异常是强制我们catch或方法声明throws的异常。如果不处理，编译器会报错。计的目的是为了提醒开发者处理一些场景中必然可能存在的异常情况。比如IOException  </li><li>RuntimeException：运行时异常，这种异常我们不需要处理，完全由虚拟机接管。比如我们常见的NullPointerException，我们在写程序时不会进行catch或throw。  </li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我怎么隐隐约约觉得写过异常相关的文章 但是找不到了。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2021/07/12/java-%E5%BC%82%E5%B8%B8/1.png&quot; class=&quot;&quot; title=&quot;This is </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql 索引什么时候更新</title>
    <link href="https://yiyayamaya.github.io/2021/07/09/mysql-%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%9B%B4%E6%96%B0/"/>
    <id>https://yiyayamaya.github.io/2021/07/09/mysql-%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%9B%B4%E6%96%B0/</id>
    <published>2021-07-09T03:47:23.000Z</published>
    <updated>2021-07-09T03:51:42.035Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/17282041/when-does-mysql-update-the-indexes" target="_blank" rel="noopener">https://stackoverflow.com/questions/17282041/when-does-mysql-update-the-indexes</a></p><p>索引更新有两个方面。</p><p>第一部分是在索引中插入/更新/删除条目。一旦记录更改，索引就会更新，并且此过程会阻止查询直到完成。<br>这允许基于索引列上的条件更快地检索记录，这是索引最容易理解的目的。</p><p>第二部分是更新索引的统计信息。这允许优化器确定对于给定查询是否值得使用索引。<br>更新不会自动进行。这些统计数据应定期手动更新ANALYZE TABLE [table_name]。</p><blockquote><p><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=209" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12b411K7Zu?p=209</a> mysql尚硅谷视频 跳着看的 看到p209</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/17282041/when-does-mysql-update-the-indexes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://stackove</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql 索引选择的原理—优化器</title>
    <link href="https://yiyayamaya.github.io/2021/07/09/mysql-%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E7%9A%84%E5%8E%9F%E7%90%86%E2%80%94%E4%BC%98%E5%8C%96%E5%99%A8/"/>
    <id>https://yiyayamaya.github.io/2021/07/09/mysql-%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E7%9A%84%E5%8E%9F%E7%90%86%E2%80%94%E4%BC%98%E5%8C%96%E5%99%A8/</id>
    <published>2021-07-09T03:35:55.000Z</published>
    <updated>2021-07-09T03:52:13.435Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_39846186/article/details/113370118" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39846186/article/details/113370118</a></p><h3 id="选择索引是mysql决定的"><a href="#选择索引是mysql决定的" class="headerlink" title="选择索引是mysql决定的"></a>选择索引是mysql决定的</h3><p>写 SQL 语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由 MySQL 来确定的。<br>有这种情况，一条本来可以执行得很快的语句，却由于 MySQL 选错了索引，而导致执行速度变得很慢。  </p><blockquote><p>将慢查询日志的阈值设置为 0，表示这个线程接下来的语句都会被记录入慢查询日志中<br>set long_query_time=0;</p></blockquote><h3 id="选择索引是mysql的优化器的工作，主要依据扫描行数。"><a href="#选择索引是mysql的优化器的工作，主要依据扫描行数。" class="headerlink" title="选择索引是mysql的优化器的工作，主要依据扫描行数。"></a>选择索引是mysql的优化器的工作，主要依据扫描行数。</h3><p>选择索引是优化器的工作。而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p><h3 id="扫描行数是怎么判断的"><a href="#扫描行数是怎么判断的" class="headerlink" title="扫描行数是怎么判断的"></a>扫描行数是怎么判断的</h3><p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。<br>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上<font color=red>不同的值的个数</font>，我们称之为“基数”(cardinality)。也就是说，这个基数越大，索引的区分度越好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_39846186/article/details/113370118&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/weixin_398</summary>
      
    
    
    
    
  </entry>
  
</feed>
