<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>皇姑区第一亚索的博客</title>
  
  
  <link href="https://yiyayamaya.github.io/atom.xml" rel="self"/>
  
  <link href="https://yiyayamaya.github.io/"/>
  <updated>2022-04-01T21:14:55.442Z</updated>
  <id>https://yiyayamaya.github.io/</id>
  
  <author>
    <name>皇姑区第一亚索</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hashMap treeMap linkedHashMap</title>
    <link href="https://yiyayamaya.github.io/2022/04/01/hashMap-treeMap-linkedHashMap/"/>
    <id>https://yiyayamaya.github.io/2022/04/01/hashMap-treeMap-linkedHashMap/</id>
    <published>2022-04-01T21:09:24.000Z</published>
    <updated>2022-04-01T21:14:55.442Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap、LinkedHashMap、TreeMap区别使用场景<br> HashMap中k的值没有顺序，常用来做统计。<br> LinkedHashMap吧。它内部有一个链表，保持Key插入的顺序。迭代的时候，也是按照插入顺序迭代<br> TreeMap的顺序是Key的自然顺序（如整数从小到大），也可以指定比较函数。但不是插入的顺序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HashMap、LinkedHashMap、TreeMap区别使用场景&lt;br&gt; HashMap中k的值没有顺序，常用来做统计。&lt;br&gt; LinkedHashMap吧。它内部有一个链表，保持Key插入的顺序。迭代的时候，也是按照插入顺序迭代&lt;br&gt; TreeMap的顺序是Ke</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>懈怠时应该想的</title>
    <link href="https://yiyayamaya.github.io/2022/03/26/%E6%87%88%E6%80%A0%E6%97%B6%E5%BA%94%E8%AF%A5%E6%83%B3%E7%9A%84/"/>
    <id>https://yiyayamaya.github.io/2022/03/26/%E6%87%88%E6%80%A0%E6%97%B6%E5%BA%94%E8%AF%A5%E6%83%B3%E7%9A%84/</id>
    <published>2022-03-26T21:03:29.000Z</published>
    <updated>2022-03-27T00:05:55.780Z</updated>
    
    <content type="html"><![CDATA[<p>群友<br>高考比自己低但是挣得比自己多的人<br>大学同学<br>马上奔3 最后的机会就是25之前</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;群友&lt;br&gt;高考比自己低但是挣得比自己多的人&lt;br&gt;大学同学&lt;br&gt;马上奔3 最后的机会就是25之前&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cs 570 迷宫作业的思考</title>
    <link href="https://yiyayamaya.github.io/2022/03/26/cs-570-%E8%BF%B7%E5%AE%AB%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://yiyayamaya.github.io/2022/03/26/cs-570-%E8%BF%B7%E5%AE%AB%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2022-03-26T19:12:38.000Z</published>
    <updated>2022-03-27T00:15:24.035Z</updated>
    
    <content type="html"><![CDATA[<p>迷宫作业要求<br><a href="https://drive.google.com/file/d/1PX44v9dnboodE5qrMB0PsvmVGwTDOXjB/view?usp=sharing" target="_blank" rel="noopener">https://drive.google.com/file/d/1PX44v9dnboodE5qrMB0PsvmVGwTDOXjB/view?usp=sharing</a></p><p>从给定起点是否能够走到终点</p><p>如果这个点不是红色可走 不能(为什么需要这么标记？)<br>如果界外 不能<br>出口之终极出口 如果已经是终点 加入path 返回能<br>如果递归能找到任何一个方向的一个 其他也有可能的方向是否被加入了？我认为不应该被加入<br> 加入path 返回true</p><p>{<br>有没有一种可能 好好走能走 因为选择了错误的路 堵死了本来可行的路<br>应该是没有 一个点可以往堵死可行的走 证明他可以走到可行 那可行的也不过是走到这个点<br>可行的可以走到更多点 因为过来了才走不到？<br>没可能  过来了的之影响了过来了的璐<br>}<br>如果递归都失败了 </p><p>Java中的短路逻辑运算符</p><p>如果逻辑表达式的求值在完成求值之前退出，则称为短路。发生短路是因为即使在表达式的完整计算之前结果就很清楚了，并且返回了结果。短路评估避免了不必要的工作并导致高效处理。</p><p>在 AND 的情况下，表达式会被计算直到我们得到一个错误的结果，因为结果总是错误的，与其他条件无关。如果存在带有 &amp;&amp;(逻辑与) 的表达式，并且第一个操作数本身为假，则发生短路，不计算进一步的表达式，并返回假。</p><p>短路走法一个走通了立马不试别的了vs不短路走法 一个走通了也要试试别的<br>只找一条路短路走法就好了<br>不短路走法会把一些路径变黑</p><p>找所有路径 bfs dfs都可以<br><a href="https://blog.csdn.net/K346K346/article/details/51289478" target="_blank" rel="noopener">https://blog.csdn.net/K346K346/article/details/51289478</a></p><p>二叉树的基本bfs dfs写法是几乎一摸一样的 只是queue和stack的区别</p><p>while{<br>    pop/poll<br>    操作<br>    Left非空则进<br>    right非空则进<br>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;迷宫作业要求&lt;br&gt;&lt;a href=&quot;https://drive.google.com/file/d/1PX44v9dnboodE5qrMB0PsvmVGwTDOXjB/view?usp=sharing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;htt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql group by 时候空值的问题</title>
    <link href="https://yiyayamaya.github.io/2022/03/25/mysql-group-by-%E6%97%B6%E5%80%99%E7%A9%BA%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://yiyayamaya.github.io/2022/03/25/mysql-group-by-%E6%97%B6%E5%80%99%E7%A9%BA%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-25T19:03:04.000Z</published>
    <updated>2022-03-26T04:48:19.587Z</updated>
    
    <content type="html"><![CDATA[<p>使用group by子句如何显示count()等于0的结果<br><a href="https://blog.csdn.net/qq_24309787/article/details/84976762" target="_blank" rel="noopener">https://blog.csdn.net/qq_24309787/article/details/84976762</a></p><p>#TODO 子查询里的count<br><a href="https://blog.csdn.net/qq_35456045/article/details/105180611" target="_blank" rel="noopener">https://blog.csdn.net/qq_35456045/article/details/105180611</a><br>561 lecture4里面第一次出现 lecture5 lecture6里都有讲解<br>有空看一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用group by子句如何显示count()等于0的结果&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/qq_24309787/article/details/84976762&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP request 和response</title>
    <link href="https://yiyayamaya.github.io/2022/01/24/HTTP-request-%E5%92%8Cresponse/"/>
    <id>https://yiyayamaya.github.io/2022/01/24/HTTP-request-%E5%92%8Cresponse/</id>
    <published>2022-01-24T06:24:30.000Z</published>
    <updated>2022-01-27T01:55:02.231Z</updated>
    
    <content type="html"><![CDATA[<p>http消息结构两种命名体系</p><img src="/2022/01/24/HTTP-request-%E5%92%8Cresponse/2022-01-24_14-25.png" class="" title="This is an example image"><p>场景：想要post下载文件，因为get下载文件参数只能 通过url传递，长度受限制。</p><p>ps.<br>jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。</p><p>从上面的解释中可以知道：ajax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。</p><p>所以我用一句话来总结两者的关系：我们使用XMLHttpRequest对象来发送一个Ajax请求。</p><p>也就是本来用XMLHttpRequest发最朴素的http psot/get，有了ajax以后就用ajax发 http post/get，省得每次都创建操作XMLHttpRequest。</p><p>ajax post和表单post的区别</p><p>没有区别，只是 AJAX 是，正如首字母缩写词所暗示的那样，是异步的，这意味着它不会阻止其他任何东西运行。表单和 AJAX 请求都发送 POST 请求，唯一的区别是浏览器使用表单 POST 请求的响应来加载新页面，其中 AJAX 请求响应被传递给 JavaScript 中的回调。</p><p>Ajax 请求是在后台异步发送的 xhr 请求，由您的 javascript 代码处理，而表单请求是普通请求，将重新加载浏览器页面以及浏览器呈现的响应</p><p>提交 HTML 表单会构造一个根据为 HTML 表单定义的规则格式化的 HTTP 请求，并使浏览器导航到它获得的响应。</p><p>使用 JavaScript 发出请求允许编程构建更多种类的请求——包括添加自定义标头、以不同方式（例如 JSON）格式化数据，以及与 HTML 表单构建请求的方式相同——并导致响应用 JavaScript 处理。</p><p>为什么不能用ajax下载？<br>ajax请求返回的参数是json,text,html,xml类型，ajax不能调用IO流，所以不可以完成下载功能，ajax可以获取文件的数据，但是不能保存到磁盘，为了保证计算机安全，JS不可以和磁盘进行交互。</p><p>Hi Amanda,</p><p>My name is Xingjian Wu and I was originally admitted to 21Fall semester and I deferred to 22Spring. But my visa is issued util this march. So I chose to take courses as a non-maticulating student this Spring semester. Before about January 10th, I am not sure the time when I can arrive US. Once I know I can arrive US on March, I submit the non-matriculating application. （In the process, I keep communicating with Bianka.） But after the application approveled. There are few courses avaliable.</p><p>I originally wrote CS561WS and CS545WS in the non-matriculating application form, and I have enrolled in CS561WS successfully but my override application for CS545WS  was rejected (I have submitted an application for the second time and it is in progress now).I would like to enroll in two more courses in addition to the CS561WS, any two from CS545WS, CS546WS, CS570WS, CS574WS. But they are either closed or I am not eligible.</p><ol><li>I submitted the Request Enrollment in Closed Course Section for CS546WS and CS570WS. Can you please help me approve it?</li></ol><ol start="2"><li>What may happen if I enroll in a course from workday before notifying non-matriculating apartment? (For example, CS546WS releases a seat, and I enroll in it but it is not on my non-matriculating application form)</li></ol><p>通过contoller传过去参数  下载&lt;-&gt;get<br>跳转一次  从8991发到8999 从8999再发到8999 </p><p>不reset 跨域仍在 不影响下载 </p><p>用post来下载 vs 用表单get/表单post来下载</p><p>表单的get post和http get post的关系？</p><p>尝试1 get里加消息体 不会<br>、<br>post ajax没有跨域问题 get ajax有跨域问题？</p><p>in () 有bug</p><p>chrp</p><p>为什么ajax不允许写磁盘 为什么表单就可以</p><p>0不能跳 不能点击 颜色黑色</p><input type="text" value="⬇️⬇️" readonly="" class="" id="emoji-copy"><p>⬇️⬇️</p><p>{1：[],2:[],3:[]}</p><p>前：前<br>后：后<br>前：后<br>后：前</p><p>span6～12的父亲的a都去掉</p><p>List&lt;Map&lt;Integer,String&gt;&gt;}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;http消息结构两种命名体系&lt;/p&gt;
&lt;img src=&quot;/2022/01/24/HTTP-request-%E5%92%8Cresponse/2022-01-24_14-25.png&quot; class=&quot;&quot; title=&quot;This is an example image&quot;&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>创建List或者Map的时候指定类型与不指定类型有什么区别</title>
    <link href="https://yiyayamaya.github.io/2022/01/03/%E5%88%9B%E5%BB%BAList%E6%88%96%E8%80%85Map%E7%9A%84%E6%97%B6%E5%80%99%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://yiyayamaya.github.io/2022/01/03/%E5%88%9B%E5%BB%BAList%E6%88%96%E8%80%85Map%E7%9A%84%E6%97%B6%E5%80%99%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-04T02:40:44.000Z</published>
    <updated>2022-01-04T07:07:39.367Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://bbs.csdn.net/topics/390949113" target="_blank" rel="noopener">https://bbs.csdn.net/topics/390949113</a></p><p>如：创建一个List<br>List list = new ArrayList();<br>List<String> list = new ArrayList<String>();<br>创建一个Map<br>Map map = new HashMap();<br>Map&lt;String,String&gt; map = HashMap&lt;String,String&gt;();<br>指定类型与不指定类型，这两种方式在底层有什么区别，或者在性能上有什么影响呢？</p><p>指定了参数类型编译器在编译期间就会帮助你检查存入容器的对象是不是参数类型！不是就会报错！保证了类型安全！性能上没什么影响，因为泛型在运行期间会擦除！就是说用不用类型参数在运行期间编译后的运行代码是一样的！ Map map = new HashMap(); Map&lt;String,String&gt; map1 =new HashMap&lt;String,String&gt;(); System.out.println(map.getClass().equals(map1.getClass()));返回结果会true；说明他们运行的是同一份字节码！</p><hr><p>一个好的使用泛型的例子</p><img src="/2022/01/04/%E5%88%9B%E5%BB%BAList%E6%88%96%E8%80%85Map%E7%9A%84%E6%97%B6%E5%80%99%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/2022-01-04_11-29.png" class="" title="This is an example image"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Gen&lt;Integer&gt; intOb = <span class="keyword">new</span> Gen&lt;Integer&gt;(<span class="number">88</span>);</span><br><span class="line">intOb.showType();</span><br><span class="line"><span class="keyword">int</span> i = intOb.getOb();</span><br><span class="line">System.out.println(<span class="string">"value= "</span> + i);</span><br><span class="line">System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line"><span class="comment">// 定义泛型类Gen的一个String版本</span></span><br><span class="line">Gen&lt;String&gt; strOb = <span class="keyword">new</span> Gen&lt;String&gt;(<span class="string">"Hello Gen!"</span>);</span><br><span class="line">strOb.showType();</span><br><span class="line">String s = strOb.getOb();</span><br><span class="line">System.out.println(<span class="string">"value= "</span> + s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 定义类Gen2的一个Integer版本</span></span><br><span class="line"></span><br><span class="line">Gen2 intOb_ = <span class="keyword">new</span> Gen2(<span class="keyword">new</span> Integer(<span class="number">88</span>));</span><br><span class="line">intOb_.showTyep();</span><br><span class="line"><span class="keyword">int</span> i_ = (Integer) intOb_.getOb();</span><br><span class="line">System.out.println(<span class="string">"value= "</span> + i_);</span><br><span class="line">System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line"><span class="comment">// 定义类Gen2的一个String版本</span></span><br><span class="line">Gen2 strOb_ = <span class="keyword">new</span> Gen2(<span class="string">"Hello Gen!"</span>);</span><br><span class="line">strOb_.showTyep();</span><br><span class="line">String s_ = (String) strOb_.getOb();</span><br><span class="line">System.out.println(<span class="string">"value= "</span> + s_);</span><br></pre></td></tr></table></figure><p>泛型带?的用法  上界通配符 <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265105899616928" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1265105899616928</a></p><p>使用类似&lt;? extends Number&gt;通配符作为方法参数时表示：</p><p>方法内部可以调用获取Number引用的方法，例如：Number n = obj.getFirst();；</p><p>方法内部无法调用传入Number引用的方法（null除外），例如：obj.setFirst(Number n);。</p><p>即一句话总结：使用extends通配符表示可以读，不能写。</p><p>使用类似<T extends Number>定义泛型类时表示：</p><p>泛型类型限定为Number以及Number的子类。</p><hr><img src="/2022/01/04/%E5%88%9B%E5%BB%BAList%E6%88%96%E8%80%85Map%E7%9A%84%E6%97%B6%E5%80%99%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/2022-01-04_14-46.png" class="" title="This is an example image"><p>所以我的尴尬症就犯了。实际上，编译器脑袋里认定的逻辑是这样的：</p><p>苹果 IS-A 水果<br>装苹果的盘子 NOT-IS-A 装水果的盘子<br>所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。<br>原因很明显，因为Plate<Apple>不是Plate<Fruit>的子类，因此，printFruit(Plate<Fruit>)不接受参数类型Plate<Apple>。</p><p>为了让泛型用起来更舒服，Sun的大脑袋们就想出了&lt;? extends T&gt;和&lt;? super T&gt;的办法，来让“水果盘子”和“苹果盘子”之间发生关系。</p><p>Plate&lt;？ extends Fruit&gt;</p><p>翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。</p><p>supper类似 下面图里表示用了&lt;?extends/super&gt;后能装的范围</p><div style="width:50%;white-space: nowrap;"   ><img src="/2022/01/04/%E5%88%9B%E5%BB%BAList%E6%88%96%E8%80%85Map%E7%9A%84%E6%97%B6%E5%80%99%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/lowerBounds.png" class="" title="This is an example image"><img src="/2022/01/04/%E5%88%9B%E5%BB%BAList%E6%88%96%E8%80%85Map%E7%9A%84%E6%97%B6%E5%80%99%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/upperBounds.png" class="" title="This is an example image"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://bbs.csdn.net/topics/390949113&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bbs.csdn.net/topics/390949113&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如：创建一个Lis</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>动态添加dom再绑定事件再解绑事件</title>
    <link href="https://yiyayamaya.github.io/2021/12/31/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0dom%E5%86%8D%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%86%8D%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6/"/>
    <id>https://yiyayamaya.github.io/2021/12/31/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0dom%E5%86%8D%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%86%8D%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6/</id>
    <published>2021-12-31T06:30:58.000Z</published>
    <updated>2021-12-31T07:14:52.628Z</updated>
    
    <content type="html"><![CDATA[<p>需求：动态添加的多个dom对,需要分别绑定事件。而且要往事件里面传参。</p><p>遇到的几个问题：<br>1.动态添加dom,因为是动态添加的dom,不能使用 $(‘#dom的id’).on(‘click’, function () {}); 这种方式 必须用$(document).on</p><p>$(document).on的原型有两种</p><img src="/2021/12/31/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0dom%E5%86%8D%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%86%8D%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6/2021-12-31_14-42.png" class="" title="This is an example image"><p>2.$(document).on的selector用class还是id？如果用class是每个dom绑定一次还是添加后所有dom按class绑定一次？</p><p>不能每个dom绑定一次，这样前面添加的dom都被多次。<br>所有dom按照class绑定一次,这样不能分别传参。<br>最后每个每一个id有一个on绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> dataKey <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="keyword">var</span> dataValue=data[dataKey];</span><br><span class="line"></span><br><span class="line">    $(<span class="string">"#exeStatWindow"</span>).append( <span class="string">'&lt;button class="layui-btn " id="'</span>+ip+dataKey+  <span class="string">'"&gt;'</span>+dataKey+<span class="string">'&lt;/button&gt;'</span>)</span><br><span class="line">    <span class="keyword">var</span> selector=<span class="string">"#"</span>+ip+dataKey</span><br><span class="line">    selector=selector.replaceAll(<span class="string">":"</span>,<span class="string">"\\:"</span>)</span><br><span class="line">    selector=selector.replaceAll(<span class="string">"."</span>,<span class="string">"\\."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一个id有自己的一个on绑定</span></span><br><span class="line">    $(<span class="built_in">document</span>).on( &#123;<span class="string">'click.myevent'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            openExeStatTable(e.data.dataKey,e.data.dataValue)</span><br><span class="line">        &#125;&#125;,selector,  &#123;</span><br><span class="line">        dataKey: dataKey,</span><br><span class="line">        dataValue: dataValue</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.seletor里面的冒号需要转义</p><p>4.添加dom成功了也通过事件传参成功了。但是如果一个dom被添加了两次就会重复，所以每次添加前先把之前的remove。问题出现了，虽然dom没了,但是它绑定的事件还在,又会一个第二次添加的dom，绑上了第一次的事件，身上有了两个事件。<br>解决：每次remove dom之前把它这个id绑定的事件给<a href="https://stackoverflow.com/a/22400945" target="_blank" rel="noopener">$(document).off掉</a> 。 （因为之前是通过id给on上的所以现在也用id给off掉 我试了id给on上 用class给off掉 貌似不行 不确定）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">end: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> father=$(<span class="string">"#exeStatWindow"</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> childs = father.childNodes;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = childs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(  $(childs[i])[<span class="number">0</span>].id)</span><br><span class="line">        <span class="keyword">var</span> selector=<span class="string">"#"</span>+$(childs[i])[<span class="number">0</span>].id</span><br><span class="line">        $(<span class="built_in">document</span>).off(<span class="string">'click.myevent'</span>, selector);</span><br><span class="line">        childs[i].remove()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>5.得保证每个dom唯一id</p><p>6.我发现其实没必要硬要通过绑定事件传参，每个dom通过自己id从全局变量里读就行了。</p><p>7.我发现layui那lay-filter实现了这个功能(动态添加的dom绑定了能传参的事件) 而且我以前还用过 想看看他怎么实现的 完全看不懂</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;需求：动态添加的多个dom对,需要分别绑定事件。而且要往事件里面传参。&lt;/p&gt;
&lt;p&gt;遇到的几个问题：&lt;br&gt;1.动态添加dom,因为是动态添加的dom,不能使用 $(‘#dom的id’).on(‘click’, function () {}); 这种方式 必须用$(doc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>css display:inline display:block</title>
    <link href="https://yiyayamaya.github.io/2021/12/21/css-display-inline-display-block/"/>
    <id>https://yiyayamaya.github.io/2021/12/21/css-display-inline-display-block/</id>
    <published>2021-12-21T11:50:12.000Z</published>
    <updated>2021-12-22T02:01:48.062Z</updated>
    
    <content type="html"><![CDATA[<p>在&lt;p&gt;&lt;/p&gt; 标签里面嵌套 div 等 原生块级元素  会在渲染页面时候出错，div 标签会出现在p标签的下方并且和p标签同级。</p><p>没有达到 div 是 p 标签的子元素的预期。</p><p>这是因为p标签里面不能嵌套原生块级元素。</p><p>只需要把  原生块级元素  换为 span 等行内元素就可以实现效果了。并且加上 display : block; 样式也不会出错。 </p><p>display：block的作用是让其他标签如：a、span等行内元素获得div的特性，比较常用于<a><span>这两个标签——因为这两个标签非块元素，如果不用display：block定义一下，那么定义width、height等和长宽相关的css属性时会发现完全不生效。</p><p>CSS块级元素和行内元素</p><p>块级元素：</p><p>独占一行；元素的宽高、以及内外边距都可设置；元素宽度在不设置的情况下，是它本身父容器的100%。</p><p>行内元素：</p><p>不会自动进行换行；元素的宽高不可设置；内边距可以设置、外边距水平方向有效，竖直方向无效；元素宽度在不设置的情况下，随内部元素的内容变化。</p><p>我们知道display:inline 和display:block的用发了，他们的作用是将块级元素转化为内联元素或者是内联元素转化为块级元素。</p><p>现在的这个貌似是两个的结合体：inline-block 为什么在我加载的这个场景能发挥奇效? 说不清</p><p>inline-block是元素具备了两种（块级和内联）元素的功能，inline最重要的一点就是：元素能够在一行展示，block 元素让它能设置宽高(有宽高能显示)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt; 标签里面嵌套 div 等 原生块级元素  会在渲染页面时候出错，div 标签会出现在p标签的下方并且和p标签同级。&lt;/p&gt;
&lt;p&gt;没有达到 div 是 p 标签的子元素的预期。&lt;/p&gt;
&lt;p&gt;这是因为p标签里面不能嵌套原生块级元素。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql 技术内幕(InnoDB存储引擎)第2版 笔记</title>
    <link href="https://yiyayamaya.github.io/2021/12/20/mysql-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0/"/>
    <id>https://yiyayamaya.github.io/2021/12/20/mysql-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-20T12:22:40.000Z</published>
    <updated>2021-12-20T13:03:00.144Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/gaochundong/p/binary_search_tree.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaochundong/p/binary_search_tree.html</a><br>一个二叉树的查找时间是线性的，定位时间也是线性的，那相比数组来说到底哪里有优势呢？毕竟数组的查找时间虽然是线性 O(n)，但定位时间却是常量 O(1) 啊？的确是这样，通常来说普通的二叉树确实不能提供比数组更好的性能。然而，如果我们按照一定的规则来组织排列二叉树中的元素时，就可以很大程度地改善查询时间和定位时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/gaochundong/p/binary_search_tree.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/gaochundon</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ajax会自动将返回的对象属性首字母转化为小写</title>
    <link href="https://yiyayamaya.github.io/2021/12/15/Ajax%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%A6%96%E5%AD%97%E6%AF%8D%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%B0%8F%E5%86%99/"/>
    <id>https://yiyayamaya.github.io/2021/12/15/Ajax%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%A6%96%E5%AD%97%E6%AF%8D%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%B0%8F%E5%86%99/</id>
    <published>2021-12-16T03:01:47.000Z</published>
    <updated>2021-12-16T03:02:12.715Z</updated>
    
    <content type="html"><![CDATA[<p>不知道是只有ajax还是所有http请求</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道是只有ajax还是所有http请求&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql 多行变一行</title>
    <link href="https://yiyayamaya.github.io/2021/12/15/mysql-%E5%A4%9A%E8%A1%8C%E5%8F%98%E4%B8%80%E8%A1%8C/"/>
    <id>https://yiyayamaya.github.io/2021/12/15/mysql-%E5%A4%9A%E8%A1%8C%E5%8F%98%E4%B8%80%E8%A1%8C/</id>
    <published>2021-12-16T02:14:50.000Z</published>
    <updated>2022-01-14T03:09:54.649Z</updated>
    
    <content type="html"><![CDATA[<p>写的不错<br>SELECT name ,<br>MAX(CASE type WHEN ‘数学’ THEN score ELSE 0 END ) math,<br>MAX(CASE type WHEN ‘英语’ THEN score ELSE 0 END ) English ,<br>MAX(CASE type WHEN ‘语文’ THEN score ELSE 0 END ) Chinese<br>FROM stu<br>GROUP BY name<br><a href="https://blog.csdn.net/rainyspring4540/article/details/50231435" target="_blank" rel="noopener">https://blog.csdn.net/rainyspring4540/article/details/50231435</a></p><p>这个case when的写法一步一步演变</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">version</span>,<span class="keyword">group_concat</span>(<span class="keyword">type</span>,<span class="string">':'</span>,score) step0,</span><br><span class="line">               <span class="keyword">group_concat</span>(<span class="keyword">type</span>,<span class="string">':'</span>,<span class="keyword">CASE</span> <span class="keyword">type</span> <span class="keyword">WHEN</span>  <span class="string">'0'</span>  <span class="keyword">THEN</span> score <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) step1, </span><br><span class="line">                <span class="keyword">group_concat</span>(<span class="keyword">CASE</span> <span class="keyword">type</span> <span class="keyword">WHEN</span>  <span class="string">'0'</span>  <span class="keyword">THEN</span> score <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) step2,        </span><br><span class="line">                <span class="keyword">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">type</span> <span class="keyword">WHEN</span> <span class="string">'0'</span> <span class="keyword">THEN</span> score <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) step3</span><br><span class="line"></span><br><span class="line">        <span class="keyword">FROM</span> (<span class="keyword">select</span> client_file_version <span class="keyword">version</span>, machine_type <span class="keyword">type</span>, <span class="keyword">count</span>(*) score</span><br><span class="line">              <span class="keyword">from</span> atc_machine</span><br><span class="line">              <span class="keyword">group</span> <span class="keyword">by</span> client_file_version, machine_type) table_a</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">version</span>;</span><br></pre></td></tr></table></figure><p>结果如下</p><img src="/2021/12/16/mysql-%E5%A4%9A%E8%A1%8C%E5%8F%98%E4%B8%80%E8%A1%8C/2022-01-14_11-06.png" class="" title="This is an example image"><p>如果想统计1和2的可以这么写<br>SUM(CASE WHEN type in(‘1’,’2’) THEN score ELSE 0 END) yier,</p><p>这篇没咋看<br><a href="https://www.cnblogs.com/weix-l/p/7521278.html" target="_blank" rel="noopener">https://www.cnblogs.com/weix-l/p/7521278.html</a></p><p>乱入讲join性能的<br>因为之前写了一个复杂的(机器类型:总数) left join (机器类型:具有心跳机器数) left join (机器类型:开启机器数) 变成了 (机器类型:总数:具有心跳机器数:开启机器数)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.machineType, a.totalCount, b.machineWithLivingHeartbeatCount, c.machineStatusOnCount</span><br><span class="line">        <span class="keyword">from</span> (<span class="keyword">select</span> machine_type machineType, <span class="keyword">count</span>(*) totalCount <span class="keyword">from</span> atc_machine <span class="keyword">group</span> <span class="keyword">by</span> machine_type) a</span><br><span class="line">                 <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">             (<span class="keyword">select</span> machine_type, <span class="keyword">count</span>(*) machineWithLivingHeartbeatCount</span><br><span class="line">              <span class="keyword">from</span> atc_machine</span><br><span class="line">              <span class="keyword">where</span> <span class="keyword">DATE_ADD</span>(last_heartbeat, <span class="built_in">INTERVAL</span> <span class="comment">#&#123;interval&#125; MINUTE) &gt; NOW()</span></span><br><span class="line">              <span class="keyword">group</span> <span class="keyword">by</span> machine_type) b</span><br><span class="line">             <span class="keyword">on</span> a.machineType = b.machine_type</span><br><span class="line">                 <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">             (<span class="keyword">select</span> machine_type, <span class="keyword">count</span>(*) machineStatusOnCount</span><br><span class="line">              <span class="keyword">from</span> atc_machine</span><br><span class="line">              <span class="keyword">where</span> <span class="keyword">status</span> = <span class="number">1</span></span><br><span class="line">              <span class="keyword">group</span> <span class="keyword">by</span> machine_type) c</span><br><span class="line">             <span class="keyword">on</span> a.machineType = c.machine_type;</span><br></pre></td></tr></table></figure><p><a href="https://database.51cto.com/art/202011/631613.htm" target="_blank" rel="noopener">https://database.51cto.com/art/202011/631613.htm</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写的不错&lt;br&gt;SELECT name ,&lt;br&gt;MAX(CASE type WHEN ‘数学’ THEN score ELSE 0 END ) math,&lt;br&gt;MAX(CASE type WHEN ‘英语’ THEN score ELSE 0 END ) English</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>开坑之WebSecurityConfigurerAdapter</title>
    <link href="https://yiyayamaya.github.io/2021/12/15/%E5%BC%80%E5%9D%91%E4%B9%8BWebSecurityConfigurerAdapter/"/>
    <id>https://yiyayamaya.github.io/2021/12/15/%E5%BC%80%E5%9D%91%E4%B9%8BWebSecurityConfigurerAdapter/</id>
    <published>2021-12-15T07:28:48.000Z</published>
    <updated>2021-12-15T07:48:31.974Z</updated>
    
    <content type="html"><![CDATA[<p>maven里依赖了<br><dependency><br>    <groupId>org.springframework.boot</groupId><br>    <artifactId>spring-boot-starter-security</artifactId><br></dependency></p><p>就导致页面上要登陆 密码是随机生成的 在日志里有</p><p>然后加一个public class SecurityConfiguration extends WebSecurityConfigurerAdapter {}的配置<br>这玩意有什么用 不加行不行</p><p><a href="https://spring.io/blog/2013/07/03/spring-security-java-config-preview-web-security/#wsca" target="_blank" rel="noopener">https://spring.io/blog/2013/07/03/spring-security-java-config-preview-web-security/#wsca</a></p><p>可能会从雷丰阳带你过spring源码中学到这个 可是我只看了几集</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;maven里依赖了&lt;br&gt;&lt;dependency&gt;&lt;br&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;br&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>开坑之maven怎么排除parent里面的依赖</title>
    <link href="https://yiyayamaya.github.io/2021/12/15/%E5%BC%80%E5%9D%91%E4%B9%8Bmaven%E6%80%8E%E4%B9%88%E6%8E%92%E9%99%A4parent%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BE%9D%E8%B5%96/"/>
    <id>https://yiyayamaya.github.io/2021/12/15/%E5%BC%80%E5%9D%91%E4%B9%8Bmaven%E6%80%8E%E4%B9%88%E6%8E%92%E9%99%A4parent%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BE%9D%E8%B5%96/</id>
    <published>2021-12-15T07:25:09.000Z</published>
    <updated>2021-12-15T07:27:44.373Z</updated>
    
    <content type="html"><![CDATA[<p>maven parent中的依赖不能用exclude排除 </p><p><a href="https://blog.csdn.net/qq_32596527/article/details/112969562" target="_blank" rel="noopener">https://blog.csdn.net/qq_32596527/article/details/112969562</a><br>试了 在我的项目里有问题 不知道和 <type>pom</type> <scope>import</scope> 有没有关系</p><p><a href="https://stackoverflow.com/questions/2681759/is-there-anyway-to-exclude-artifacts-inherited-from-a-parent-pom" target="_blank" rel="noopener">https://stackoverflow.com/questions/2681759/is-there-anyway-to-exclude-artifacts-inherited-from-a-parent-pom</a><br>一个回答说了一堆没看懂几条</p><p>感觉应该系统学习下maven的配置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;maven parent中的依赖不能用exclude排除 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_32596527/article/details/112969562&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>same-origin policy与跨域资源共享CORS</title>
    <link href="https://yiyayamaya.github.io/2021/12/15/same-origin-policy%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS/"/>
    <id>https://yiyayamaya.github.io/2021/12/15/same-origin-policy%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS/</id>
    <published>2021-12-15T05:48:58.000Z</published>
    <updated>2021-12-21T06:11:15.714Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器同源政策及其规避方法<br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p><p>跨域资源共享 CORS 详解<br><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/04/cors.html</a><br>此篇文章貌似没给出太具体的解决</p><p>springboot被请求的api 可以加@CrossOrigin解决 </p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3789624.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/3789624.html</a> HttpServletResponse对象介绍</p><p><a href="https://www.jianshu.com/p/8bc6b82403c5" target="_blank" rel="noopener">https://www.jianshu.com/p/8bc6b82403c5</a> 一篇差不多的介绍 貌似结构清晰一些</p><p>同一个人讲的 HttpServletRequest和HttpServletResponse<br><a href="https://blog.csdn.net/qq_34666857/article/details/104677407" target="_blank" rel="noopener">https://blog.csdn.net/qq_34666857/article/details/104677407</a></p><p><a href="https://blog.csdn.net/qq_34666857/article/details/104838171" target="_blank" rel="noopener">https://blog.csdn.net/qq_34666857/article/details/104838171</a></p><p>廖雪峰结合servlet讲的<br><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1328705066500130" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1328705066500130</a></p><p>　　Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。<br>request和response对象即然代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行了。要向客户机输出数据，只需要找response对象就行了。</p><p>　　HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。查看HttpServletResponse的API，可以看到这些相关的方法。</p><p>之前跨域出问题 就是因为@CrosOrigin注解会让spring会往response里加Access-Control-Allow-Origin解决跨域 但是我操作了response把这个头给重置掉 写到这我去试了一下再给那个下载的respose加一个Access-Control-Allow-Origin头 果然跨域问题解决了</p><p>http get 可以开始下载 ajax get url不能开始下载 为什么？ 其实硬要也可以 但是通常都是http get啊<a href="https://www.cnblogs.com/nuccch/p/7151228.html" target="_blank" rel="noopener">https://www.cnblogs.com/nuccch/p/7151228.html</a></p><p>1，负责向客户端(浏览器)发送数据的相关方法 **</p><p>1.getOutputStream()    该方法用于返回Servlet引擎创建的字节输出流对象，Servlet程序可以按字节形式输出响应正文。<br>2.getWriter()    该方法用于返回Servlet引擎创建的字符输出流对象，Servlet程序可以按字符形式输出响应正文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浏览器同源政策及其规避方法&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruany</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql 求时间的绝对差 timediff 有坑</title>
    <link href="https://yiyayamaya.github.io/2021/12/14/mysql-%E6%B1%82%E6%97%B6%E9%97%B4%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%B7%AE-timediff-%E6%9C%89%E5%9D%91/"/>
    <id>https://yiyayamaya.github.io/2021/12/14/mysql-%E6%B1%82%E6%97%B6%E9%97%B4%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%B7%AE-timediff-%E6%9C%89%E5%9D%91/</id>
    <published>2021-12-14T08:47:16.000Z</published>
    <updated>2021-12-14T08:50:16.694Z</updated>
    
    <content type="html"><![CDATA[<p>SELECT TIMEDIFF(“00:00:03”, “00:00:02”);<br>结果00:00:01</p><p>SELECT TIMEDIFF(“00:00:03”, “00:00:02”);<br>结果也是00:00:01</p><p>但是跨天又正常了</p><p>SELECT timediff(‘2010-01-01 01:00:00’, ‘2010-01-02 01:00:00’);<br>-24:00:00</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SELECT TIMEDIFF(“00:00:03”, “00:00:02”);&lt;br&gt;结果00:00:01&lt;/p&gt;
&lt;p&gt;SELECT TIMEDIFF(“00:00:03”, “00:00:02”);&lt;br&gt;结果也是00:00:01&lt;/p&gt;
&lt;p&gt;但是跨天又正常了&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>以前看到过一篇很好的大offset limit优化的文章 现在找不到了</title>
    <link href="https://yiyayamaya.github.io/2021/11/29/%E4%BB%A5%E5%89%8D%E7%9C%8B%E5%88%B0%E8%BF%87%E4%B8%80%E7%AF%87%E5%BE%88%E5%A5%BD%E7%9A%84%E5%A4%A7offset-limit%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%87%E7%AB%A0-%E7%8E%B0%E5%9C%A8%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86/"/>
    <id>https://yiyayamaya.github.io/2021/11/29/%E4%BB%A5%E5%89%8D%E7%9C%8B%E5%88%B0%E8%BF%87%E4%B8%80%E7%AF%87%E5%BE%88%E5%A5%BD%E7%9A%84%E5%A4%A7offset-limit%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%87%E7%AB%A0-%E7%8E%B0%E5%9C%A8%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86/</id>
    <published>2021-11-30T02:17:34.000Z</published>
    <updated>2021-12-09T08:55:52.908Z</updated>
    
    <content type="html"><![CDATA[<p>之前是某公司的ppt 现在找不到了</p><p>找到了 妈的</p><p><a href="https://www.slideshare.net/slideshow/view?login=Eweaver&amp;preview=no&amp;slideid=1&amp;title=efficient-pagination-using-mysql" target="_blank" rel="noopener">https://www.slideshare.net/slideshow/view?login=Eweaver&amp;preview=no&amp;slideid=1&amp;title=efficient-pagination-using-mysql</a></p><p><a href="https://stackoverflow.com/questions/4481388/why-does-mysql-higher-limit-offset-slow-the-query-down" target="_blank" rel="noopener">https://stackoverflow.com/questions/4481388/why-does-mysql-higher-limit-offset-slow-the-query-down</a></p><p>MySQL cannot go directly to the 10000th record (or the 80000th byte as your suggesting) because it cannot assume that it’s packed/ordered like that (or that it has continuous values in 1 to 10000). Although it might be that way in actuality, MySQL cannot assume that there are no holes/gaps/deleted ids.</p><p>So, as bobs noted, MySQL will have to fetch 10000 rows (or traverse through 10000th entries of the index on id) before finding the 30 to return.</p><p>EDIT : To illustrate my point</p><p>Note that although</p><p>SELECT * FROM large ORDER BY id LIMIT 10000, 30<br>would be slow(er),</p><p>SELECT * FROM large WHERE id &gt;  10000 ORDER BY id LIMIT 30<br>would be fast(er), and would return the same results provided that there are no missing ids (i.e. gaps).</p><p>MySQL 不能直接转到第 10000 条记录（或您建议的第 80000 字节），因为它不能假设它是这样打包/排序的（或者它在 1 到 10000 之间具有连续值）。尽管实际上可能是这样，但 MySQL 不能假设没有漏洞/间隙/删除的 id。<br>因此，正如 bob 所指出的，id在找到要返回的 30 行之前，MySQL 必须获取 10000 行（或遍历索引的第 10000 个条目）。</p><p>请注意，虽然</p><p>SELECT * FROM large ORDER BY id LIMIT 10000, 30<br>会很慢（呃），</p><p>SELECT * FROM large WHERE id &gt;  10000 ORDER BY id LIMIT 30 </p><p>将是fast(er)，并且会返回相同的结果，前提是没有丢失的ids（即间隙）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前是某公司的ppt 现在找不到了&lt;/p&gt;
&lt;p&gt;找到了 妈的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.slideshare.net/slideshow/view?login=Eweaver&amp;amp;preview=no&amp;amp;slideid=1&amp;amp;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>List=new ArrayList写法的意义</title>
    <link href="https://yiyayamaya.github.io/2021/11/19/List=new-ArrayList%E5%86%99%E6%B3%95%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>https://yiyayamaya.github.io/2021/11/19/List=new-ArrayList%E5%86%99%E6%B3%95%E7%9A%84%E6%84%8F%E4%B9%89/</id>
    <published>2021-11-19T07:29:21.000Z</published>
    <updated>2022-01-20T06:03:56.434Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文问题的兄弟问题 <a href="https://segmentfault.com/q/1010000040306308" target="_blank" rel="noopener">https://segmentfault.com/q/1010000040306308</a> 我提的问题父类 x = new 子类();的意义</p></blockquote><p>List<String> list = new ArrayList&lt;&gt;();<br>多年来令我费解<br>这个问题的不同问法有为什么面向接口编程？</p><blockquote><p>插曲<br>实现接口的方法一定要声明为public，因为接口中定义的方法都是默认为public（可以省略不写）的。</p></blockquote><p>这个回答讲的很好烦人的苍蝇和烦人的电话推销员的例子<br>但是他讲的是为什么要用接口 不能回答上面的问题 L l=new AL;<br><a href="https://stackoverflow.com/a/384067" target="_blank" rel="noopener">https://stackoverflow.com/a/384067</a></p><p>我惊讶地发现实现了同一个接口的两个类居然都可以放进参数声明为借口的方法中<br>这么基本的功能我现在才意识到<br>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">IPest[] iPestsArr=<span class="keyword">new</span> IPest[]&#123;telemarketer1,telemarketer2,houseFly1,houseFly2&#125;;</span><br><span class="line"></span><br><span class="line">再比如</span><br><span class="line">IPest就是恼人行为的接口</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">inviteIPestOnly</span><span class="params">(IPest iPest)</span> </span>&#123;</span><br><span class="line">       iPest.BeAnnoying();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">HouseFly</span> <span class="keyword">implements</span> <span class="title">IPest</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">   <span class="title">HouseFly</span> <span class="title">houseFly1</span> </span>= <span class="keyword">new</span> HouseFly();</span><br><span class="line"></span><br><span class="line">   diningRoom.inviteIPestOnly(houseFly1);</span><br></pre></td></tr></table></figure><p>接口可以被理解成弱化的继承。<br>他也是一种分类手段，当不同类的对象(电话推销员、苍蝇)表现出相同特征(恼人)时通过这个特征来分类。<br>原文:I finally understood their use as a language construct by thinking of them as a means of classifying common traits or behaviors that were exhibited by potentially many non-related classes of objects.</p><blockquote><p>插播下策略模式<br>interface Fly, interface highhighFly extends Fly, interface landFly extends Fly</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">protected</span> FlyBehavior flyBehavior;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       flyBehavior.fly();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>定义下策略模式：定义了算法族(陆地飞、高高地飞)，分别封装起来让他们可以相互替换。让算法的变化独立于使用算法的客户(各种duck)。</p></blockquote><p>这样做的好处之一<br>这个设计在 DiningRoom 和各种 Pests 之间耦合得足够松散，你可以引入新的害虫（想想 class Covid19 implements IPest {…};！），在编写 DiningRoom 类时甚至不存在！您不仅不需要更改Diningroom，甚至不需要重新编译它！在测试和大型项目中派上用场</p><p>但是上面的写法仅仅解释了为什么用接口 而没有解释<br>HouseFly houseFly1 = new HouseFly();<br>InterfaceAnnoying houseFly1 = new HouseFly(); 两种写法的区别。在这里例子里两种写法都ok。</p><p>同问题下一个更切题的答案<br>stackoverflow.com/a/383982/9868445</p><p>我在v2ex上提问<br><a href="https://www.v2ex.com/t/829411#reply26" target="_blank" rel="noopener">https://www.v2ex.com/t/829411#reply26</a></p><p>感觉说的比较好的是</p><p>限定只能用 List 的方法。<br>只用和只能用还是有点区别的，这么写最大好处是防手滑。</p><p>代码防御； 可以让后面调用的人，只能调用接口声明的方法，而不会误调用 具体实现的某些公开方法。<br>在后续，如果要切换具体的实现，只要替换 new ArrayList 即可，对调用方无感知。</p><p>个人提炼：我从一开始 List=new AL 下面我每次用到list的时候都不会碰AL专属的方法。 如果我AL=new AL了 就可能不小心用了一个AL专属方法<br>以后再改成linkedList就不好改了</p><img src="/2021/11/19/List=new-ArrayList%E5%86%99%E6%B3%95%E7%9A%84%E6%84%8F%E4%B9%89/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220120140127.png" class="" title="This is an example image">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文问题的兄弟问题 &lt;a href=&quot;https://segmentfault.com/q/1010000040306308&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/q/10</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文档</title>
    <link href="https://yiyayamaya.github.io/2021/11/17/%E6%96%87%E6%A1%A3/"/>
    <id>https://yiyayamaya.github.io/2021/11/17/%E6%96%87%E6%A1%A3/</id>
    <published>2021-11-18T02:02:04.000Z</published>
    <updated>2021-11-18T03:07:40.240Z</updated>
    
    <content type="html"><![CDATA[<p>要统计的一天=第一天=atc_task_logs_20211117<br>第二天=atc_task_logs_20211118</p><hr><h4 id="一-第一天每个小类型创建数"><a href="#一-第一天每个小类型创建数" class="headerlink" title="一 第一天每个小类型创建数"></a>一 第一天每个小类型创建数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> task_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> atc_task_logs_20211117 <span class="keyword">where</span> <span class="keyword">event</span>=<span class="number">1</span> <span class="keyword">group</span> <span class="keyword">by</span> task_name</span><br></pre></td></tr></table></figure><hr><h4 id="二-第一天创建的所有任务的独一标志hashKey"><a href="#二-第一天创建的所有任务的独一标志hashKey" class="headerlink" title="二 第一天创建的所有任务的独一标志hashKey"></a>二 第一天创建的所有任务的独一标志hashKey</h4><p>return${第一天创建的hashKey集合}</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hash_key <span class="keyword">from</span> atc_task_logs_20211117   <span class="keyword">where</span> <span class="keyword">event</span>=<span class="number">1</span> <span class="keyword">and</span> hash_key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><hr><h4 id="三-统计当天成功和第二天成功"><a href="#三-统计当天成功和第二天成功" class="headerlink" title="三 统计当天成功和第二天成功"></a>三 统计当天成功和第二天成功</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当天成功</span><br><span class="line"><span class="keyword">select</span> task_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> atc_task_logs_20211117</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">event</span>=<span class="number">4</span></span><br><span class="line">        <span class="keyword">and</span> hash_key <span class="keyword">in</span> $&#123;第一天创建的hashKey集合&#125;</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> task_name</span><br><span class="line"></span><br><span class="line">第二天成功</span><br><span class="line"><span class="keyword">select</span> task_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> atc_task_logs_20211118</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">event</span>=<span class="number">4</span></span><br><span class="line">        <span class="keyword">and</span> hash_key <span class="keyword">in</span> $&#123;第一天创建的hashKey集合&#125;</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> task_name</span><br></pre></td></tr></table></figure><hr><h4 id="四-类似第三步-统计当天强制失败和第二天强制失败"><a href="#四-类似第三步-统计当天强制失败和第二天强制失败" class="headerlink" title="四 类似第三步 统计当天强制失败和第二天强制失败"></a>四 类似第三步 统计当天强制失败和第二天强制失败</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当天失败</span><br><span class="line"><span class="keyword">select</span> task_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> atc_task_logs_20211117</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">event</span>=<span class="number">7</span></span><br><span class="line">        <span class="keyword">and</span> hash_key <span class="keyword">in</span> $&#123;第一天创建的hashKey集合&#125;</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> task_name</span><br><span class="line"></span><br><span class="line">第二天强制失败</span><br><span class="line"><span class="keyword">select</span> task_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> atc_task_logs_20211118</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">event</span>=<span class="number">7</span></span><br><span class="line">        <span class="keyword">and</span> hash_key <span class="keyword">in</span> $&#123;第一天创建的hashKey集合&#125;</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> task_name</span><br></pre></td></tr></table></figure><hr><h4 id="五-第一天创建的hashKey第二天也出现了-说明最后一次event出现在第二天"><a href="#五-第一天创建的hashKey第二天也出现了-说明最后一次event出现在第二天" class="headerlink" title="五 第一天创建的hashKey第二天也出现了 说明最后一次event出现在第二天"></a>五 第一天创建的hashKey第二天也出现了 说明最后一次event出现在第二天</h4><p>return ${结束在第二天的event的id的集合} </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">id</span>) <span class="keyword">from</span> atc_task_logs_20211118</span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">       hash_key <span class="keyword">in</span> $&#123;第一天创建的hashKey集合&#125;</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> hash_key</span><br></pre></td></tr></table></figure><h4 id="五点五-第一天创建的hashKey第二天也出现了-说明最后一次event出现在第二天"><a href="#五点五-第一天创建的hashKey第二天也出现了-说明最后一次event出现在第二天" class="headerlink" title="五点五 第一天创建的hashKey第二天也出现了 说明最后一次event出现在第二天"></a>五点五 第一天创建的hashKey第二天也出现了 说明最后一次event出现在第二天</h4><p>return ${结束在第二天的hashKey集合}</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hash_key <span class="keyword">from</span> atc_task_logs_20211118</span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">         hash_key <span class="keyword">in</span> $&#123;第一天创建的hashKey集合&#125;</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> hash_key</span><br></pre></td></tr></table></figure><hr><h4 id="六-统计第一天的（event-5）失败"><a href="#六-统计第一天的（event-5）失败" class="headerlink" title="六 统计第一天的（event=5）失败"></a>六 统计第一天的（event=5）失败</h4><p>${第一天创建的hashKey集合} - ${结束在第二天的hashKey集合} = ${结束在第一天的hashKey集合}</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">id</span>) <span class="keyword">from</span> atc_task_logs_20211117</span><br><span class="line">       <span class="keyword">where</span></span><br><span class="line">       hash_key <span class="keyword">in</span> $&#123;结束在第一天的hashKey集合&#125;</span><br><span class="line">       <span class="keyword">group</span> <span class="keyword">by</span> hash_key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> task_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> atc_task_logs_20211117</span><br><span class="line">       <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">event</span>=<span class="number">5</span></span><br><span class="line">         <span class="keyword">and</span> <span class="keyword">id</span> <span class="keyword">in</span> $&#123;结束在第一天的<span class="keyword">event</span>的<span class="keyword">id</span>的集合&#125;</span><br><span class="line">       <span class="keyword">group</span> <span class="keyword">by</span> task_name</span><br></pre></td></tr></table></figure><hr><h4 id="七-类似地-统计下第二天的（event-5）失败"><a href="#七-类似地-统计下第二天的（event-5）失败" class="headerlink" title="七 类似地 统计下第二天的（event=5）失败"></a>七 类似地 统计下第二天的（event=5）失败</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> task_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> atc_task_logs_20211118</span><br><span class="line">       <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">event</span>=<span class="number">5</span></span><br><span class="line">         <span class="keyword">and</span> <span class="keyword">id</span> <span class="keyword">in</span> $&#123;结束在第二天的<span class="keyword">event</span>的<span class="keyword">id</span>的集合&#125; </span><br><span class="line">       <span class="keyword">group</span> <span class="keyword">by</span> task_name</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要统计的一天=第一天=atc_task_logs_20211117&lt;br&gt;第二天=atc_task_logs_20211118&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;一-第一天每个小类型创建数&quot;&gt;&lt;a href=&quot;#一-第一天每个小类型创建数&quot; class=&quot;headerlin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>x86 x86_64 x64这几个说法到底怎么回事</title>
    <link href="https://yiyayamaya.github.io/2021/11/17/x86-x86-64-x64%E8%BF%99%E5%87%A0%E4%B8%AA%E8%AF%B4%E6%B3%95%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/"/>
    <id>https://yiyayamaya.github.io/2021/11/17/x86-x86-64-x64%E8%BF%99%E5%87%A0%E4%B8%AA%E8%AF%B4%E6%B3%95%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/</id>
    <published>2021-11-17T08:21:06.000Z</published>
    <updated>2021-11-17T09:35:34.553Z</updated>
    
    <content type="html"><![CDATA[<p>我们现在家用的全都是64位x86指令集  21世纪初家用的以前可能是32位x86指令集</p><p>32位x86指令集是英特尔发明的 本来从1980～2000年大家都用的好好的 后来发现32位不够了 想加到64位<br>这时候因特尔飘了  他做了一种不兼容32位x86的64位x86指令集 结果阴险的amd趁机做了一套兼容32位x86的64位x86指令集<br>甚至大言不惭的把这套命名为amd64<br>因特尔很不爽 但也没办法 给amd64起了个小名叫x86_64 来掩盖这个专利归amd所有的事</p><p>神发明了重骑女枪 并把它命名为7人口重骑女枪 本来大家都用的好好的 但是赛季末疯狂出花灯暴金币 游戏通常在9人口结束<br>这时候神想更进一步 他把7人口中的人马去掉 多出来的三个人口可以上三个骑士凑出4骑士 这也导致玩法和之前不兼容从而没有流行起来<br>阴险的窃贼手套趁机在神的7人口重骑女枪基础上挂2个秘术 前7个人口完全不变 甚至并大言不惭地把这个阵容命名为许氏重骑女枪<br>因为这个阵容和之前完全兼容 在没脑子的玩家里流传很广<br>神很不爽 但也没办法 但是神坚持叫这套阵容为9人口重骑女枪 来掩盖窃贼手套的贡献</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们现在家用的全都是64位x86指令集  21世纪初家用的以前可能是32位x86指令集&lt;/p&gt;
&lt;p&gt;32位x86指令集是英特尔发明的 本来从1980～2000年大家都用的好好的 后来发现32位不够了 想加到64位&lt;br&gt;这时候因特尔飘了  他做了一种不兼容32位x86的6</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>springBoot 自动配置遇到的问题</title>
    <link href="https://yiyayamaya.github.io/2021/10/28/springBoot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://yiyayamaya.github.io/2021/10/28/springBoot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-28T09:20:30.000Z</published>
    <updated>2021-10-28T09:24:55.212Z</updated>
    
    <content type="html"><![CDATA[<p>1.配置数据源问题 application.yml可不可以什么都不写？<br>不配置数据源可能会报错 可能需要 @SpringBootApplication(exclude ={ DataSourceAutoConfiguration.class})<br>但是有时候不exclude也不报错？ 不懂为什么</p><p>2.用到shardingsphere时候，仅仅在maven中引用，没在任何地方调用就会报错(缺少shardingsphere的数据源配置)。<br>第一次遇见 是因为自动配置吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shardingsphere&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.配置数据源问题 application.yml可不可以什么都不写？&lt;br&gt;不配置数据源可能会报错 可能需要 @SpringBootApplication(exclude ={ DataSourceAutoConfiguration.class})&lt;br&gt;但是有时候不ex</summary>
      
    
    
    
    
  </entry>
  
</feed>
